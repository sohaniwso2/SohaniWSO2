/* The following code was generated by JFlex 1.2.2 on 11-7-27 ����10:57 */

/*******************************************************************************
 * Copyright (c) 2006 Zend Corporation and IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Zend and IBM - Initial implementation
 *******************************************************************************/
/*nlsXXX*/
package org.eclipse.php.internal.core.documentModel.parser;

import java.io.CharArrayReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.resources.IProject;
import org.eclipse.php.internal.core.PHPVersion;
import org.eclipse.php.internal.core.documentModel.parser.regions.PhpScriptRegion;
import org.eclipse.php.internal.core.project.ProjectOptions;
import org.eclipse.wst.sse.core.internal.ltk.parser.BlockMarker;
import org.eclipse.wst.sse.core.internal.ltk.parser.BlockTokenizer;
import org.eclipse.wst.sse.core.internal.provisional.text.ITextRegion;
import org.eclipse.wst.sse.core.internal.provisional.text.ITextRegionList;
import org.eclipse.wst.sse.core.internal.util.Debug;
import org.eclipse.wst.sse.core.utils.StringUtils;
import org.eclipse.wst.xml.core.internal.Logger;
import org.eclipse.wst.xml.core.internal.parser.ContextRegionContainer;
import org.eclipse.wst.xml.core.internal.parser.IntStack;
import org.eclipse.wst.xml.core.internal.parser.regions.XMLParserRegionFactory;
import org.eclipse.wst.xml.core.internal.regions.DOMRegionContext;

/**
 * This class is a scanner generated by <a
 * href="http://www.informatik.tu-muenchen.de/~kleing/jflex/">JFlex</a> 1.2.2 on
 * 11-7-27 ����10:57 from the specification file
 * <tt>file:/F:/php/pdt/pdtnewest3/org.eclipse.php.core/Resources/parserTools/highlighting/PHPTokenizer.jflex</tt>
 */
public class PHPTokenizer implements BlockTokenizer, PHPRegionContext,
		DOMRegionContext {

	/** this character denotes the end of file */
	final public static int YYEOF = -1;

	/** lexical states */
	final public static int ST_XML_COMMENT_END = 4;
	final public static int ST_BLOCK_TAG_SCAN = 30;
	final public static int ST_DHTML_ATTRIBUTE_VALUE = 14;
	final public static int ST_XML_PI_ATTRIBUTE_NAME = 8;
	final public static int ST_DHTML_TAG_CLOSE = 15;
	final public static int ST_XML_ATTRIBUTE_VALUE_DQUOTED = 33;
	final public static int ST_DHTML_EQUALS = 13;
	final public static int ST_XML_PI_ATTRIBUTE_VALUE = 10;
	final public static int ST_XML_ATTRIBUTE_VALUE = 19;
	final public static int ST_XML_ATTRIBUTE_VALUE_SQUOTED = 32;
	final public static int ST_XML_ATTRIBUTE_NAME = 17;
	final public static int ST_XML_EQUALS = 18;
	final public static int YYINITIAL = 0;
	final public static int ST_XML_DOCTYPE_ID_SYSTEM = 25;
	final public static int ST_XML_ELEMENT_DECLARATION = 26;
	final public static int ST_XML_DECLARATION_CLOSE = 21;
	final public static int ST_XML_DOCTYPE_DECLARATION = 22;
	final public static int ST_CDATA_END = 2;
	final public static int ST_PI_WS = 6;
	final public static int ST_CDATA_TEXT = 1;
	final public static int ST_XML_ELEMENT_DECLARATION_CONTENT = 27;
	final public static int ST_XML_ATTLIST_DECLARATION = 28;
	final public static int ST_XML_PI_EQUALS = 9;
	final public static int ST_XML_ATTLIST_DECLARATION_CONTENT = 29;
	final public static int ST_XML_DOCTYPE_ID_PUBLIC = 24;
	final public static int ST_DHTML_ATTRIBUTE_NAME = 12;
	final public static int ST_PHP_CONTENT = 31;
	final public static int ST_ABORT_EMBEDDED = 15;
	final public static int ST_XML_DOCTYPE_EXTERNAL_ID = 23;
	final public static int ST_PI_CONTENT = 7;
	final public static int ST_BLOCK_TAG_INTERNAL_SCAN = 15;
	final public static int ST_PI = 5;
	final public static int ST_XML_DECLARATION = 20;
	final public static int ST_XML_TAG_NAME = 16;
	final public static int ST_XML_PI_TAG_CLOSE = 11;
	final public static int ST_XML_COMMENT = 3;

	/**
	 * Translates characters to character classes
	 */
	final private static String yycmap_packed = "\11\0\1\5\1\22\2\0\1\14\22\0\1\14\1\21\1\11\1\56" + //$NON-NLS-1$
			"\1\71\1\17\1\12\1\13\1\16\1\16\1\16\1\16\1\16\1\7" + //$NON-NLS-1$
			"\1\6\1\3\12\15\1\10\1\62\1\1\1\42\1\2\1\4\1\16" + //$NON-NLS-1$
			"\1\26\1\63\1\24\1\25\1\45\1\60\1\33\1\70\1\37\1\33" + //$NON-NLS-1$
			"\1\33\1\53\1\54\1\41\1\40\1\44\1\33\1\35\1\57\1\27" + //$NON-NLS-1$
			"\1\61\2\33\1\52\1\43\1\33\1\23\1\0\1\20\1\0\1\10" + //$NON-NLS-1$
			"\1\0\1\47\1\63\1\64\1\50\1\34\1\60\1\33\1\67\1\37" + //$NON-NLS-1$
			"\2\33\1\32\1\31\1\41\1\40\1\44\1\33\1\35\1\36\1\46" + //$NON-NLS-1$
			"\1\61\1\33\1\33\1\30\1\51\1\33\1\72\1\55\72\0\1\66" + //$NON-NLS-1$
			"\10\0\27\65\1\0\37\65\1\0\72\65\2\0\13\65\2\0\10\65" + //$NON-NLS-1$
			"\1\0\65\65\1\0\104\65\11\0\44\65\3\0\2\65\4\0\36\65" + //$NON-NLS-1$
			"\70\0\131\65\22\0\7\65\16\0\2\66\56\0\106\66\32\0\2\66" + //$NON-NLS-1$
			"\44\0\1\65\1\66\3\65\1\0\1\65\1\0\24\65\1\0\54\65" + //$NON-NLS-1$
			"\1\0\7\65\3\0\1\65\1\0\1\65\1\0\1\65\1\0\1\65" + //$NON-NLS-1$
			"\1\0\22\65\15\0\14\65\1\0\102\65\1\0\14\65\1\0\44\65" + //$NON-NLS-1$
			"\1\0\4\66\11\0\65\65\2\0\2\65\2\0\2\65\3\0\34\65" + //$NON-NLS-1$
			"\2\0\10\65\2\0\2\65\67\0\46\65\2\0\1\65\7\0\46\65" + //$NON-NLS-1$
			"\12\0\21\66\1\0\27\66\1\0\3\66\1\0\1\66\1\0\2\66" + //$NON-NLS-1$
			"\1\0\1\66\13\0\33\65\5\0\3\65\56\0\32\65\5\0\1\66" + //$NON-NLS-1$
			"\12\65\10\66\15\0\12\66\6\0\1\66\107\65\2\0\5\65\1\0" + //$NON-NLS-1$
			"\17\65\1\0\4\65\1\0\1\65\17\66\2\65\2\66\1\0\4\66" + //$NON-NLS-1$
			"\2\0\12\66\u0207\0\3\66\1\0\65\65\2\0\1\66\1\65\20\66" + //$NON-NLS-1$
			"\3\0\4\66\3\0\12\65\2\66\2\0\12\66\21\0\3\66\1\0" + //$NON-NLS-1$
			"\10\65\2\0\2\65\2\0\26\65\1\0\7\65\1\0\1\65\3\0" + //$NON-NLS-1$
			"\4\65\2\0\1\66\1\0\7\66\2\0\2\66\2\0\3\66\11\0" + //$NON-NLS-1$
			"\1\66\4\0\2\65\1\0\3\65\2\66\2\0\12\66\2\65\20\0" + //$NON-NLS-1$
			"\1\66\2\0\6\65\4\0\2\65\2\0\26\65\1\0\7\65\1\0" + //$NON-NLS-1$
			"\2\65\1\0\2\65\1\0\2\65\2\0\1\66\1\0\5\66\4\0" + //$NON-NLS-1$
			"\2\66\2\0\3\66\13\0\4\65\1\0\1\65\7\0\12\66\2\66" + //$NON-NLS-1$
			"\3\65\14\0\3\66\1\0\7\65\1\0\1\65\1\0\3\65\1\0" + //$NON-NLS-1$
			"\26\65\1\0\7\65\1\0\2\65\1\0\5\65\2\0\1\66\1\65" + //$NON-NLS-1$
			"\10\66\1\0\3\66\1\0\3\66\22\0\1\65\5\0\12\66\21\0" + //$NON-NLS-1$
			"\3\66\1\0\10\65\2\0\2\65\2\0\26\65\1\0\7\65\1\0" + //$NON-NLS-1$
			"\2\65\2\0\4\65\2\0\1\66\1\65\6\66\3\0\2\66\2\0" + //$NON-NLS-1$
			"\3\66\10\0\2\66\4\0\2\65\1\0\3\65\4\0\12\66\22\0" + //$NON-NLS-1$
			"\2\66\1\0\6\65\3\0\3\65\1\0\4\65\3\0\2\65\1\0" + //$NON-NLS-1$
			"\1\65\1\0\2\65\3\0\2\65\3\0\3\65\3\0\10\65\1\0" + //$NON-NLS-1$
			"\3\65\4\0\5\66\3\0\3\66\1\0\4\66\11\0\1\66\17\0" + //$NON-NLS-1$
			"\11\66\21\0\3\66\1\0\10\65\1\0\3\65\1\0\27\65\1\0" + //$NON-NLS-1$
			"\12\65\1\0\5\65\4\0\7\66\1\0\3\66\1\0\4\66\7\0" + //$NON-NLS-1$
			"\2\66\11\0\2\65\4\0\12\66\22\0\2\66\1\0\10\65\1\0" + //$NON-NLS-1$
			"\3\65\1\0\27\65\1\0\12\65\1\0\5\65\4\0\7\66\1\0" + //$NON-NLS-1$
			"\3\66\1\0\4\66\7\0\2\66\7\0\1\65\1\0\2\65\4\0" + //$NON-NLS-1$
			"\12\66\22\0\2\66\1\0\10\65\1\0\3\65\1\0\27\65\1\0" + //$NON-NLS-1$
			"\20\65\4\0\6\66\2\0\3\66\1\0\4\66\11\0\1\66\10\0" + //$NON-NLS-1$
			"\2\65\4\0\12\66\221\0\56\65\1\0\1\65\1\66\2\65\7\66" + //$NON-NLS-1$
			"\5\0\6\65\1\66\10\66\1\0\12\66\47\0\2\65\1\0\1\65" + //$NON-NLS-1$
			"\2\0\2\65\1\0\1\65\2\0\1\65\6\0\4\65\1\0\7\65" + //$NON-NLS-1$
			"\1\0\3\65\1\0\1\65\1\0\1\65\2\0\2\65\1\0\2\65" + //$NON-NLS-1$
			"\1\0\1\65\1\66\2\65\6\66\1\0\2\66\1\65\2\0\5\65" + //$NON-NLS-1$
			"\1\0\1\66\1\0\6\66\2\0\12\66\76\0\2\66\6\0\12\66" + //$NON-NLS-1$
			"\13\0\1\66\1\0\1\66\1\0\1\66\4\0\2\66\10\65\1\0" + //$NON-NLS-1$
			"\41\65\7\0\24\66\1\0\6\66\4\0\6\66\1\0\1\66\1\0" + //$NON-NLS-1$
			"\25\66\3\0\7\66\1\0\1\66\346\0\46\65\12\0\47\65\11\0" + //$NON-NLS-1$
			"\1\65\1\0\2\65\1\0\3\65\1\0\1\65\1\0\2\65\1\0" + //$NON-NLS-1$
			"\5\65\51\0\1\65\1\0\1\65\1\0\1\65\13\0\1\65\1\0" + //$NON-NLS-1$
			"\1\65\1\0\1\65\3\0\2\65\3\0\1\65\5\0\3\65\1\0" + //$NON-NLS-1$
			"\1\65\1\0\1\65\1\0\1\65\1\0\1\65\3\0\2\65\3\0" + //$NON-NLS-1$
			"\2\65\1\0\1\65\50\0\1\65\11\0\1\65\2\0\1\65\2\0" + //$NON-NLS-1$
			"\2\65\7\0\2\65\1\0\1\65\1\0\7\65\50\0\1\65\4\0" + //$NON-NLS-1$
			"\1\65\10\0\1\65\u0c06\0\234\65\4\0\132\65\6\0\26\65\2\0" + //$NON-NLS-1$
			"\6\65\2\0\46\65\2\0\6\65\2\0\10\65\1\0\1\65\1\0" + //$NON-NLS-1$
			"\1\65\1\0\1\65\1\0\37\65\2\0\65\65\1\0\7\65\1\0" + //$NON-NLS-1$
			"\1\65\3\0\3\65\1\0\7\65\3\0\4\65\2\0\6\65\4\0" + //$NON-NLS-1$
			"\15\65\5\0\3\65\1\0\7\65\323\0\15\66\4\0\1\66\104\0" + //$NON-NLS-1$
			"\1\65\3\0\2\65\2\0\1\65\121\0\3\65\u0e82\0\1\66\1\0" + //$NON-NLS-1$
			"\1\65\31\0\11\65\6\66\1\0\5\66\13\0\124\65\4\0\2\66" + //$NON-NLS-1$
			"\2\0\2\66\2\0\132\65\1\0\3\66\6\0\50\65\u1cd3\0\u51a6\65" + //$NON-NLS-1$
			"\u0c5a\0\u2ba4\65\134\0\u0800\0\u1ffe\0\2\0"; //$NON-NLS-1$

	/**
	 * Translates characters to character classes
	 */
	final private static char[] yycmap = yy_unpack_cmap(yycmap_packed);

	/**
	 * Translates a state to a row index in the transition table
	 */
	final private static int yy_rowMap[] = { 0, 59, 118, 177, 236, 295, 354,
			413, 472, 531, 590, 649, 708, 767, 826, 885, 944, 1003, 1062, 1121,
			1180, 1239, 1298, 1357, 1416, 1475, 1534, 1593, 1652, 1711, 1770,
			1829, 1888, 1947, 2006, 2065, 2124, 2183, 2242, 2301, 2242, 2301,
			2360, 2242, 2242, 2301, 2419, 2478, 2537, 2596, 2655, 2714, 2773,
			2832, 2242, 2301, 2891, 2950, 3009, 2242, 3068, 3068, 3127, 3186,
			3245, 2891, 2242, 3304, 3363, 2242, 3422, 3481, 3540, 3599, 3658,
			2242, 3717, 3776, 3835, 3894, 3953, 2242, 4012, 4071, 4130, 4189,
			4248, 4307, 2242, 4366, 4425, 4484, 4543, 4602, 4661, 4720, 4779,
			4779, 4838, 4897, 4956, 5015, 5015, 5074, 5133, 5192, 5251, 5251,
			5310, 5369, 5428, 5487, 2242, 5546, 5546, 5605, 5664, 5723, 5782,
			2242, 2242, 2301, 2242, 2301, 5841, 5900, 5959, 2242, 6018, 6077,
			2242, 6136, 2242, 6195, 2242, 6254, 6313, 6372, 6431, 6490, 6549,
			6608, 6667, 2242, 6726, 6785, 6844, 2242, 2242, 3068, 3186, 2242,
			3245, 3304, 3422, 3481, 6903, 3540, 2242, 6962, 3599, 2242, 7021,
			4012, 7080, 4189, 2242, 4248, 6254, 7139, 7198, 7257, 4543, 2242,
			7316, 7375, 4779, 7434, 4838, 2242, 7493, 7552, 7611, 7611, 7670,
			7729, 4956, 4779, 5015, 7788, 5074, 2242, 7847, 5133, 5192, 5015,
			5251, 7906, 5310, 2242, 7965, 8024, 8083, 8083, 8142, 8201, 8260,
			5428, 8319, 5546, 8378, 5605, 2242, 8437, 8496, 8555, 8555, 8614,
			8673, 8732, 5723, 8791, 2242, 6018, 2242, 6136, 8850, 8909, 8968,
			9027, 9086, 2242, 9145, 9204, 2242, 2242, 2242, 9263, 2596, 9322,
			9381, 9440, 9499, 9558, 9617, 7493, 9676, 9676, 7965, 9735, 9735,
			9794, 9853, 8437, 9912, 9912, 9971, 10030, 10089, 2242, 10148,
			10207, 2242, 10266, 10325, 10384, 10443, 10502, 10561, 10620,
			10679, 7670, 8142, 10738, 10797, 8614, 10856, 10915, 10974, 11033,
			11092, 11151, 11210, 11269, 11328, 11387, 11446, 11505, 11564,
			11623, 11682, 10974, 11741, 11800, 2596, 11859, 11918, 11977, 2242,
			2242, 11505, 12036, 11623, 12095, 12154, 12213, 2242, 2242, 2242,
			12272, 12331, 12390, 12449, 12508, 12567, 2242, 12626, 5428, 5723,
			12685, 12744, 12803, 12862, 2596 };

	/**
	 * The packed transition table of the DFA
	 */
	final private static String yy_packed = "\1\43\1\44\10\43\1\45\4\43\1\46\53\43\1\47" + //$NON-NLS-1$
			"\1\50\71\47\1\51\1\52\16\51\1\53\1\51\1\54" + //$NON-NLS-1$
			"\50\51\1\55\1\56\71\55\1\51\1\52\5\51\1\57" + //$NON-NLS-1$
			"\12\51\1\54\51\51\1\52\2\51\1\60\1\61\2\51" + //$NON-NLS-1$
			"\1\62\3\51\1\61\5\51\1\61\1\51\4\62\1\63" + //$NON-NLS-1$
			"\6\62\1\64\2\62\1\51\7\62\1\65\2\62\2\51" + //$NON-NLS-1$
			"\3\62\1\51\3\62\1\51\2\62\3\51\1\52\2\51" + //$NON-NLS-1$
			"\1\60\1\66\6\51\1\66\5\51\1\66\50\51\1\67" + //$NON-NLS-1$
			"\1\70\2\67\1\71\15\67\1\54\50\67\1\51\1\52" + //$NON-NLS-1$
			"\2\51\1\72\1\61\2\51\1\73\3\51\1\61\5\51" + //$NON-NLS-1$
			"\1\61\1\51\16\73\1\51\12\73\2\51\3\73\1\51" + //$NON-NLS-1$
			"\3\73\1\51\2\73\3\51\1\52\2\51\1\72\1\61" + //$NON-NLS-1$
			"\2\51\1\73\3\51\1\61\5\51\1\61\1\51\16\73" + //$NON-NLS-1$
			"\1\74\12\73\2\51\3\73\1\51\3\73\1\51\2\73" + //$NON-NLS-1$
			"\2\51\1\75\1\52\1\51\1\76\1\77\1\61\3\75" + //$NON-NLS-1$
			"\1\100\1\75\1\101\1\61\5\75\1\61\50\75\1\51" + //$NON-NLS-1$
			"\1\52\2\51\1\102\15\51\1\54\51\51\1\52\1\103" + //$NON-NLS-1$
			"\1\104\4\51\1\105\11\51\1\54\1\51\16\105\1\51" + //$NON-NLS-1$
			"\12\105\2\51\3\105\1\51\3\105\1\51\2\105\3\51" + //$NON-NLS-1$
			"\1\52\1\103\1\104\4\51\1\105\11\51\1\54\1\51" + //$NON-NLS-1$
			"\16\105\1\106\12\105\2\51\3\105\1\51\3\105\1\51" + //$NON-NLS-1$
			"\2\105\2\51\1\107\1\52\1\103\1\110\1\107\1\51" + //$NON-NLS-1$
			"\3\107\1\111\1\107\1\112\1\51\5\107\1\54\50\107" + //$NON-NLS-1$
			"\1\51\1\52\20\51\1\54\50\51\1\113\1\44\1\114" + //$NON-NLS-1$
			"\1\115\4\113\1\116\13\113\16\117\1\113\12\117\2\113" + //$NON-NLS-1$
			"\3\117\1\113\3\117\1\113\2\117\2\113\1\51\1\120" + //$NON-NLS-1$
			"\1\114\1\115\1\51\1\61\2\51\1\121\3\51\1\61" + //$NON-NLS-1$
			"\5\51\1\61\1\51\16\121\1\51\12\121\2\51\3\121" + //$NON-NLS-1$
			"\1\51\3\121\1\51\2\121\3\51\1\120\1\114\1\115" + //$NON-NLS-1$
			"\1\51\1\61\2\51\1\121\3\51\1\61\5\51\1\61" + //$NON-NLS-1$
			"\1\51\16\121\1\122\12\121\2\51\3\121\1\51\3\121" + //$NON-NLS-1$
			"\1\51\2\121\2\51\1\123\1\124\1\114\1\125\1\123" + //$NON-NLS-1$
			"\1\61\3\123\1\126\1\123\1\127\1\61\5\123\1\61" + //$NON-NLS-1$
			"\50\123\1\51\1\130\1\131\2\51\1\61\6\51\1\61" + //$NON-NLS-1$
			"\5\51\1\61\2\51\1\132\1\133\5\51\1\134\10\51" + //$NON-NLS-1$
			"\1\134\1\51\1\133\1\132\23\51\1\52\1\131\2\51" + //$NON-NLS-1$
			"\1\61\6\51\1\61\5\51\1\61\1\135\50\51\1\52" + //$NON-NLS-1$
			"\1\131\2\51\1\61\2\51\1\136\3\51\1\61\5\51" + //$NON-NLS-1$
			"\1\61\1\135\16\136\1\51\12\136\2\51\3\136\1\51" + //$NON-NLS-1$
			"\3\136\1\51\2\136\3\51\1\52\1\131\2\51\1\61" + //$NON-NLS-1$
			"\6\51\1\61\5\51\1\61\1\135\12\51\1\137\5\51" + //$NON-NLS-1$
			"\1\140\12\51\1\137\13\51\1\141\1\52\1\131\1\142" + //$NON-NLS-1$
			"\1\141\1\61\3\141\1\143\1\141\1\144\1\61\5\141" + //$NON-NLS-1$
			"\1\61\1\145\47\141\1\146\1\52\1\131\1\147\1\146" + //$NON-NLS-1$
			"\1\61\3\146\1\150\1\146\1\151\1\61\5\146\1\61" + //$NON-NLS-1$
			"\1\152\47\146\1\153\1\52\1\131\1\154\1\153\1\61" + //$NON-NLS-1$
			"\3\153\1\155\1\153\1\156\1\61\5\153\1\61\50\153" + //$NON-NLS-1$
			"\1\157\1\160\1\161\70\157\1\162\1\52\1\131\1\163" + //$NON-NLS-1$
			"\1\162\1\61\3\162\1\164\1\162\1\165\1\61\5\162" + //$NON-NLS-1$
			"\1\61\50\162\1\166\1\167\1\170\70\166\1\171\1\172" + //$NON-NLS-1$
			"\71\171\1\173\1\174\2\173\1\175\12\173\1\175\53\173" + //$NON-NLS-1$
			"\1\176\1\177\11\176\1\200\42\176\1\201\12\176\1\201" + //$NON-NLS-1$
			"\1\176\1\202\1\177\7\202\1\203\44\202\1\204\12\202" + //$NON-NLS-1$
			"\1\204\1\202\1\43\1\0\10\43\1\0\4\43\1\0" + //$NON-NLS-1$
			"\53\43\3\0\1\205\1\206\12\0\1\207\1\0\1\210" + //$NON-NLS-1$
			"\56\0\1\211\2\0\1\212\3\0\1\211\5\0\1\211" + //$NON-NLS-1$
			"\1\0\16\212\1\0\12\212\1\0\1\213\3\212\1\0" + //$NON-NLS-1$
			"\3\212\1\0\2\212\7\0\1\211\2\0\1\214\3\0" + //$NON-NLS-1$
			"\1\211\5\0\1\211\1\0\16\214\1\0\12\214\2\0" + //$NON-NLS-1$
			"\3\214\1\0\3\214\1\0\2\214\101\0\1\206\12\0" + //$NON-NLS-1$
			"\1\207\1\0\1\215\71\0\1\216\61\0\1\217\65\0" + //$NON-NLS-1$
			"\1\220\75\0\1\61\6\0\1\61\5\0\1\61\56\0" + //$NON-NLS-1$
			"\3\62\4\0\1\62\6\0\16\62\1\0\12\62\2\0" + //$NON-NLS-1$
			"\3\62\1\0\6\62\10\0\3\62\4\0\1\62\6\0" + //$NON-NLS-1$
			"\5\62\1\221\10\62\1\0\11\62\1\222\2\0\3\62" + //$NON-NLS-1$
			"\1\0\6\62\10\0\3\62\4\0\1\62\6\0\5\62" + //$NON-NLS-1$
			"\1\223\10\62\1\0\11\62\1\223\2\0\3\62\1\0" + //$NON-NLS-1$
			"\6\62\10\0\3\62\4\0\1\62\6\0\5\62\1\222" + //$NON-NLS-1$
			"\10\62\1\0\11\62\1\222\2\0\3\62\1\0\6\62" + //$NON-NLS-1$
			"\7\0\1\66\6\0\1\66\5\0\1\66\52\0\1\224" + //$NON-NLS-1$
			"\72\0\1\225\76\0\3\73\4\0\1\73\6\0\16\73" + //$NON-NLS-1$
			"\1\0\12\73\2\0\3\73\1\0\6\73\2\0\1\75" + //$NON-NLS-1$
			"\2\0\1\226\1\75\1\0\3\75\1\0\1\75\2\0" + //$NON-NLS-1$
			"\5\75\1\0\51\75\1\0\1\225\1\226\1\75\1\0" + //$NON-NLS-1$
			"\3\75\1\0\1\75\2\0\5\75\1\0\50\75\1\227" + //$NON-NLS-1$
			"\1\0\7\227\1\230\61\227\1\231\1\0\11\231\1\230" + //$NON-NLS-1$
			"\57\231\2\0\1\103\1\232\75\0\3\105\4\0\1\105" + //$NON-NLS-1$
			"\6\0\16\105\1\0\12\105\2\0\3\105\1\0\6\105" + //$NON-NLS-1$
			"\2\0\1\107\2\0\1\233\1\107\1\0\3\107\1\0" + //$NON-NLS-1$
			"\1\107\2\0\5\107\1\0\51\107\1\0\1\103\1\234" + //$NON-NLS-1$
			"\1\107\1\0\3\107\1\0\1\107\2\0\5\107\1\0" + //$NON-NLS-1$
			"\50\107\1\111\1\0\1\235\1\236\1\111\1\235\3\111" + //$NON-NLS-1$
			"\1\237\1\111\2\235\5\111\1\235\50\111\1\112\1\0" + //$NON-NLS-1$
			"\1\240\1\241\1\112\1\240\3\112\1\240\1\112\1\237" + //$NON-NLS-1$
			"\1\240\5\112\1\240\50\112\1\113\3\0\20\113\16\0" + //$NON-NLS-1$
			"\1\113\12\0\2\113\3\0\1\113\3\0\1\113\2\0" + //$NON-NLS-1$
			"\2\113\2\0\1\242\70\0\1\113\3\0\2\113\3\116" + //$NON-NLS-1$
			"\4\113\1\116\6\113\16\117\1\113\12\117\2\113\3\117" + //$NON-NLS-1$
			"\1\113\3\117\1\116\2\117\2\113\6\0\3\117\4\0" + //$NON-NLS-1$
			"\1\117\6\0\16\117\1\0\12\117\2\0\3\117\1\0" + //$NON-NLS-1$
			"\6\117\5\0\1\205\1\206\3\0\1\243\6\0\1\207" + //$NON-NLS-1$
			"\1\0\1\210\2\0\16\243\1\0\12\243\2\0\3\243" + //$NON-NLS-1$
			"\1\0\3\243\1\0\2\243\10\0\3\121\4\0\1\121" + //$NON-NLS-1$
			"\6\0\16\121\1\0\12\121\2\0\3\121\1\0\6\121" + //$NON-NLS-1$
			"\2\0\1\123\2\0\1\244\1\123\1\0\3\123\1\0" + //$NON-NLS-1$
			"\1\123\2\0\5\123\1\0\50\123\3\0\1\205\1\206" + //$NON-NLS-1$
			"\3\0\1\245\6\0\1\207\1\0\1\210\2\0\16\245" + //$NON-NLS-1$
			"\1\0\12\245\2\0\3\245\1\0\3\245\1\0\2\245" + //$NON-NLS-1$
			"\2\0\1\123\1\0\1\242\1\244\1\123\1\0\3\123" + //$NON-NLS-1$
			"\1\0\1\123\2\0\5\123\1\0\50\123\1\246\1\0" + //$NON-NLS-1$
			"\7\246\1\247\61\246\1\250\1\0\11\250\1\247\57\250" + //$NON-NLS-1$
			"\3\0\1\205\1\206\12\0\1\207\1\0\1\251\111\0" + //$NON-NLS-1$
			"\1\252\61\0\1\253\16\0\1\253\56\0\1\254\20\0" + //$NON-NLS-1$
			"\1\254\17\0\20\255\1\256\52\255\6\0\3\136\4\0" + //$NON-NLS-1$
			"\1\136\6\0\16\136\1\0\12\136\2\0\3\136\1\0" + //$NON-NLS-1$
			"\6\136\45\0\1\257\5\0\1\257\102\0\1\260\11\0" + //$NON-NLS-1$
			"\1\141\2\0\1\261\1\141\1\0\3\141\1\0\1\141" + //$NON-NLS-1$
			"\2\0\5\141\1\0\50\141\1\143\1\0\1\262\1\263" + //$NON-NLS-1$
			"\1\143\1\262\3\143\1\264\1\143\2\262\5\143\1\262" + //$NON-NLS-1$
			"\50\143\1\265\1\0\1\266\1\267\1\270\1\266\3\270" + //$NON-NLS-1$
			"\1\266\1\265\1\271\1\272\3\270\1\265\1\270\1\272" + //$NON-NLS-1$
			"\1\265\31\270\1\265\7\270\2\265\3\270\1\265\1\145" + //$NON-NLS-1$
			"\2\255\1\273\1\145\1\255\3\145\1\255\1\145\2\255" + //$NON-NLS-1$
			"\3\145\1\274\1\145\1\255\50\145\1\146\2\0\1\275" + //$NON-NLS-1$
			"\1\146\1\0\3\146\1\0\1\146\2\0\5\146\1\0" + //$NON-NLS-1$
			"\50\146\1\150\2\276\1\277\1\150\1\276\3\150\1\300" + //$NON-NLS-1$
			"\1\150\2\276\5\150\1\276\50\150\1\151\2\301\1\302" + //$NON-NLS-1$
			"\1\151\1\301\3\151\1\301\1\151\1\300\1\301\5\151" + //$NON-NLS-1$
			"\1\301\50\151\1\152\2\255\1\303\1\152\1\255\3\152" + //$NON-NLS-1$
			"\1\255\1\152\2\255\3\152\1\304\1\152\1\255\50\152" + //$NON-NLS-1$
			"\1\153\2\0\1\305\1\153\1\0\3\153\1\0\1\153" + //$NON-NLS-1$
			"\2\0\5\153\1\0\50\153\1\155\1\0\1\306\1\307" + //$NON-NLS-1$
			"\1\155\1\306\3\155\1\310\1\155\2\306\5\155\1\306" + //$NON-NLS-1$
			"\50\155\1\311\1\0\1\312\1\313\1\314\1\312\3\314" + //$NON-NLS-1$
			"\1\312\1\311\1\315\1\316\3\314\1\311\1\314\1\316" + //$NON-NLS-1$
			"\1\311\31\314\1\311\7\314\2\311\3\314\1\311\2\157" + //$NON-NLS-1$
			"\1\0\72\157\1\0\1\157\1\317\12\157\1\320\1\157" + //$NON-NLS-1$
			"\1\321\51\157\1\162\2\0\1\322\1\162\1\0\3\162" + //$NON-NLS-1$
			"\1\0\1\162\2\0\5\162\1\0\50\162\1\164\1\0" + //$NON-NLS-1$
			"\1\323\1\324\1\164\1\323\3\164\1\325\1\164\2\323" + //$NON-NLS-1$
			"\5\164\1\323\50\164\1\326\1\0\1\327\1\330\1\331" + //$NON-NLS-1$
			"\1\327\3\331\1\327\1\326\1\332\1\333\3\331\1\326" + //$NON-NLS-1$
			"\1\331\1\333\1\326\31\331\1\326\7\331\2\326\3\331" + //$NON-NLS-1$
			"\1\326\2\166\1\0\72\166\1\0\1\166\1\334\12\166" + //$NON-NLS-1$
			"\1\335\1\166\1\336\51\166\2\0\1\337\70\0\1\176" + //$NON-NLS-1$
			"\1\0\11\176\1\0\42\176\1\340\12\176\1\340\1\176" + //$NON-NLS-1$
			"\3\0\1\341\1\206\12\0\1\207\1\0\1\215\51\0" + //$NON-NLS-1$
			"\72\176\1\0\1\202\1\0\7\202\1\0\44\202\1\342" + //$NON-NLS-1$
			"\12\202\1\342\73\202\45\0\1\343\35\0\1\344\13\0" + //$NON-NLS-1$
			"\1\345\54\0\1\211\2\0\1\43\3\0\1\211\5\0" + //$NON-NLS-1$
			"\1\211\1\0\16\43\1\0\12\43\2\0\3\43\1\0" + //$NON-NLS-1$
			"\3\43\1\0\2\43\2\0\1\346\1\0\3\346\1\347" + //$NON-NLS-1$
			"\3\212\1\346\1\0\1\346\1\347\1\212\1\346\1\0" + //$NON-NLS-1$
			"\2\346\1\347\1\346\16\212\1\346\12\212\2\346\3\212" + //$NON-NLS-1$
			"\1\350\6\212\2\346\15\0\1\351\12\0\1\352\42\0" + //$NON-NLS-1$
			"\1\346\1\0\3\346\1\347\3\214\1\346\1\0\1\346" + //$NON-NLS-1$
			"\1\347\1\214\1\346\1\0\2\346\1\347\1\346\16\214" + //$NON-NLS-1$
			"\1\346\12\214\2\346\3\214\1\353\6\214\2\346\23\0" + //$NON-NLS-1$
			"\1\345\51\0\1\354\72\0\1\355\76\0\3\62\4\0" + //$NON-NLS-1$
			"\1\62\6\0\6\62\1\356\7\62\1\0\10\62\1\357" + //$NON-NLS-1$
			"\1\62\2\0\3\62\1\0\6\62\10\0\3\62\4\0" + //$NON-NLS-1$
			"\1\62\6\0\6\62\1\357\7\62\1\0\10\62\1\357" + //$NON-NLS-1$
			"\1\62\2\0\3\62\1\0\6\62\10\0\3\62\4\0" + //$NON-NLS-1$
			"\1\62\6\0\16\62\1\0\1\62\1\360\10\62\2\0" + //$NON-NLS-1$
			"\3\62\1\0\6\62\2\0\1\235\1\0\7\235\1\237" + //$NON-NLS-1$
			"\61\235\1\240\1\0\11\240\1\237\57\240\6\0\3\243" + //$NON-NLS-1$
			"\4\0\1\243\6\0\16\243\1\0\12\243\2\0\3\243" + //$NON-NLS-1$
			"\1\0\6\243\10\0\3\245\4\0\1\245\6\0\16\245" + //$NON-NLS-1$
			"\1\0\12\245\2\0\3\245\1\0\6\245\26\0\1\361" + //$NON-NLS-1$
			"\37\0\1\361\35\0\1\362\16\0\1\362\60\0\1\363" + //$NON-NLS-1$
			"\10\0\1\363\63\0\1\364\20\0\1\364\76\0\1\365" + //$NON-NLS-1$
			"\7\0\1\262\1\0\7\262\1\264\61\262\1\265\1\0" + //$NON-NLS-1$
			"\1\266\1\366\1\265\1\266\3\265\1\266\1\265\1\264" + //$NON-NLS-1$
			"\1\266\5\265\1\266\50\265\1\266\1\0\11\266\1\264" + //$NON-NLS-1$
			"\57\266\1\265\1\0\1\266\1\366\1\265\1\266\3\265" + //$NON-NLS-1$
			"\1\266\1\265\1\367\1\266\5\265\1\266\50\265\13\0" + //$NON-NLS-1$
			"\1\370\57\0\1\266\1\0\11\266\1\367\57\266\11\276" + //$NON-NLS-1$
			"\1\300\61\276\13\301\1\300\57\301\1\306\1\0\7\306" + //$NON-NLS-1$
			"\1\310\61\306\1\311\1\0\1\312\1\371\1\311\1\312" + //$NON-NLS-1$
			"\3\311\1\312\1\311\1\310\1\312\5\311\1\312\50\311" + //$NON-NLS-1$
			"\1\312\1\0\11\312\1\310\57\312\1\311\1\0\1\312" + //$NON-NLS-1$
			"\1\371\1\311\1\312\3\311\1\312\1\311\1\372\1\312" + //$NON-NLS-1$
			"\5\311\1\312\50\311\13\0\1\373\57\0\1\312\1\0" + //$NON-NLS-1$
			"\11\312\1\372\57\312\2\157\1\0\41\157\1\374\30\157" + //$NON-NLS-1$
			"\1\0\20\157\1\375\47\157\1\323\1\0\7\323\1\325" + //$NON-NLS-1$
			"\61\323\1\326\1\0\1\327\1\376\1\326\1\327\3\326" + //$NON-NLS-1$
			"\1\327\1\326\1\325\1\327\5\326\1\327\50\326\1\327" + //$NON-NLS-1$
			"\1\0\11\327\1\325\57\327\1\326\1\0\1\327\1\376" + //$NON-NLS-1$
			"\1\326\1\327\3\326\1\327\1\326\1\377\1\327\5\326" + //$NON-NLS-1$
			"\1\327\50\326\13\0\1\u0100\57\0\1\327\1\0\11\327" + //$NON-NLS-1$
			"\1\377\57\327\2\166\1\0\41\166\1\u0101\30\166\1\0" + //$NON-NLS-1$
			"\20\166\1\u0102\47\166\67\0\2\u0103\11\0\1\u0104\107\0" + //$NON-NLS-1$
			"\1\u0105\46\0\1\346\1\0\10\346\1\0\4\346\1\0" + //$NON-NLS-1$
			"\42\346\1\0\11\346\1\0\3\346\1\347\4\346\1\0" + //$NON-NLS-1$
			"\1\346\1\347\2\346\1\0\2\346\1\347\37\346\1\u0106" + //$NON-NLS-1$
			"\10\346\15\0\1\351\44\0\1\u0107\25\0\1\u0108\6\0" + //$NON-NLS-1$
			"\3\u0108\5\0\1\u0108\10\0\1\u0108\1\0\2\u0108\7\0" + //$NON-NLS-1$
			"\1\u0108\2\0\2\u0108\14\0\1\62\1\u0109\1\62\4\0" + //$NON-NLS-1$
			"\1\62\6\0\16\62\1\0\12\62\2\0\3\62\1\0" + //$NON-NLS-1$
			"\6\62\10\0\3\62\4\0\1\62\6\0\14\62\1\u010a" + //$NON-NLS-1$
			"\1\62\1\0\12\62\2\0\3\62\1\0\6\62\31\0" + //$NON-NLS-1$
			"\1\u010b\16\0\1\u010b\56\0\1\u010c\20\0\1\u010c\50\0" + //$NON-NLS-1$
			"\1\u010d\22\0\1\u010d\45\0\1\u010e\16\0\1\u010e\56\0" + //$NON-NLS-1$
			"\1\u010f\20\0\1\u010f\22\0\2\u0110\1\0\3\u0110\2\0" + //$NON-NLS-1$
			"\1\271\4\u0110\1\0\2\u0110\1\0\31\u0110\1\0\7\u0110" + //$NON-NLS-1$
			"\2\0\3\u0110\4\0\2\u0111\1\0\3\u0111\2\0\1\315" + //$NON-NLS-1$
			"\4\u0111\1\0\2\u0111\1\0\31\u0111\1\0\7\u0111\2\0" + //$NON-NLS-1$
			"\3\u0111\1\0\2\157\1\0\64\157\2\u0112\4\157\1\0" + //$NON-NLS-1$
			"\21\157\1\u0113\46\157\3\0\2\u0114\1\0\3\u0114\2\0" + //$NON-NLS-1$
			"\1\332\4\u0114\1\0\2\u0114\1\0\31\u0114\1\0\7\u0114" + //$NON-NLS-1$
			"\2\0\3\u0114\1\0\2\166\1\0\64\166\2\u0115\4\166" + //$NON-NLS-1$
			"\1\0\21\166\1\u0116\46\166\44\0\1\u0117\10\0\1\u0117" + //$NON-NLS-1$
			"\42\0\1\u0118\127\0\1\u0106\25\0\1\u0108\6\0\3\u0108" + //$NON-NLS-1$
			"\5\0\1\u0108\10\0\1\u0108\1\0\2\u0108\7\0\1\u0108" + //$NON-NLS-1$
			"\1\0\1\u0107\2\u0108\14\0\3\62\4\0\1\62\6\0" + //$NON-NLS-1$
			"\12\62\1\u0119\3\62\1\0\12\62\2\0\3\62\1\0" + //$NON-NLS-1$
			"\6\62\10\0\3\62\4\0\1\62\6\0\11\62\1\u011a" + //$NON-NLS-1$
			"\4\62\1\0\12\62\2\0\3\62\1\0\6\62\45\0" + //$NON-NLS-1$
			"\1\u011b\5\0\1\u011b\60\0\1\u011c\67\0\1\u011d\10\0" + //$NON-NLS-1$
			"\1\u011d\61\0\1\u011e\10\0\1\u011e\64\0\1\u011f\33\0" + //$NON-NLS-1$
			"\2\157\1\0\41\157\1\u0120\10\157\1\u0120\17\157\1\0" + //$NON-NLS-1$
			"\22\157\1\u0121\45\157\2\166\1\0\41\166\1\u0122\10\166" + //$NON-NLS-1$
			"\1\u0122\17\166\1\0\22\166\1\u0123\45\166\5\0\1\u0124" + //$NON-NLS-1$
			"\6\0\1\u0124\5\0\1\u0124\76\0\1\u0125\52\0\3\62" + //$NON-NLS-1$
			"\4\0\1\62\6\0\16\62\1\0\3\62\1\u0126\6\62" + //$NON-NLS-1$
			"\2\0\3\62\1\0\6\62\10\0\3\62\4\0\1\62" + //$NON-NLS-1$
			"\6\0\3\62\1\u0127\12\62\1\0\3\62\1\u0127\6\62" + //$NON-NLS-1$
			"\2\0\3\62\1\0\6\62\46\0\1\u0128\64\0\1\u0129" + //$NON-NLS-1$
			"\20\0\1\u0129\54\0\1\u012a\62\0\1\u012b\22\0\1\u012b" + //$NON-NLS-1$
			"\42\0\1\u012c\37\0\1\u012c\6\0\2\157\1\0\2\157" + //$NON-NLS-1$
			"\1\u012d\6\157\1\u012d\5\157\1\u012d\52\157\1\0\23\157" + //$NON-NLS-1$
			"\1\u012e\44\157\2\166\1\0\2\166\1\u012f\6\166\1\u012f" + //$NON-NLS-1$
			"\5\166\1\u012f\52\166\1\0\23\166\1\u0130\44\166\27\0" + //$NON-NLS-1$
			"\1\u0131\51\0\3\62\4\0\1\62\6\0\16\62\1\0" + //$NON-NLS-1$
			"\6\62\1\u0132\3\62\2\0\3\62\1\0\6\62\36\0" + //$NON-NLS-1$
			"\1\u0133\10\0\1\u0133\54\0\1\u0134\16\0\1\u0134\53\0" + //$NON-NLS-1$
			"\1\u0135\16\0\1\u0135\24\0\2\157\1\0\24\157\1\u0136" + //$NON-NLS-1$
			"\43\157\2\166\1\0\24\166\1\u0137\43\166\26\0\1\u0138" + //$NON-NLS-1$
			"\52\0\3\62\4\0\1\62\6\0\6\62\1\u0139\7\62" + //$NON-NLS-1$
			"\1\0\12\62\2\0\3\62\1\0\6\62\2\0\2\157" + //$NON-NLS-1$
			"\1\0\23\157\1\u013a\44\157\2\166\1\0\23\166\1\u013b" + //$NON-NLS-1$
			"\44\166\23\0\1\u013c\55\0\3\62\4\0\1\62\6\0" + //$NON-NLS-1$
			"\10\62\1\u013d\5\62\1\0\12\62\2\0\3\62\1\0" + //$NON-NLS-1$
			"\6\62\2\0\2\157\1\0\20\157\1\u013e\47\157\2\166" + //$NON-NLS-1$
			"\1\0\20\166\1\u013f\47\166\6\0\3\62\4\0\1\62" + //$NON-NLS-1$
			"\6\0\12\62\1\u0140\3\62\1\0\12\62\2\0\3\62" + //$NON-NLS-1$
			"\1\0\6\62\10\0\3\62\4\0\1\62\6\0\16\62" + //$NON-NLS-1$
			"\1\0\12\62\2\0\3\62\1\0\4\62\1\u0141\1\62" + //$NON-NLS-1$
			"\10\0\3\62\4\0\1\62\6\0\10\62\1\u0142\5\62" + //$NON-NLS-1$
			"\1\0\12\62\2\0\3\62\1\0\6\62\10\0\3\62" + //$NON-NLS-1$
			"\4\0\1\62\6\0\10\62\1\u0143\5\62\1\0\12\62" + //$NON-NLS-1$
			"\2\0\3\62\1\0\6\62\10\0\3\62\4\0\1\62" + //$NON-NLS-1$
			"\6\0\16\62\1\0\3\62\1\u0144\6\62\2\0\3\62" + //$NON-NLS-1$
			"\1\0\6\62\2\0"; //$NON-NLS-1$

	/**
	 * The transition table of the DFA
	 */
	final private static int yytrans[] = yy_unpack(yy_packed);

	/* error codes */
	final private static int YY_UNKNOWN_ERROR = 0;
	// final private static int YY_ILLEGAL_STATE = 1;
	final private static int YY_NO_MATCH = 2;
	final private static int YY_PUSHBACK_2BIG = 3;

	/* error messages for the codes above */
	final private static String YY_ERROR_MSG[] = {
			"Unkown internal scanner error", //$NON-NLS-1$
			"Internal error: unknown state", //$NON-NLS-1$
			"Error: could not match input", //$NON-NLS-1$
			"Error: pushback value was too large" //$NON-NLS-1$
	};

	/**
	 * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
	 */
	private final static byte YY_ATTRIBUTE[] = { 1, 0, 0, 0, 0, 1, 0, 0, 1, 1,
			1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
			0, 0, 1, 1, 1, 1, 9, 1, 9, 1, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			9, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 9, 1, 1, 9, 1, 1, 1, 1, 1, 9,
			1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 9,
			9, 1, 9, 1, 1, 1, 1, 9, 1, 1, 9, 1, 9, 1, 9, 1, 0, 1, 0, 1, 0, 0,
			0, 9, 1, 1, 1, 9, 9, 0, 0, 9, 0, 0, 0, 0, 0, 0, 9, 0, 0, 9, 1, 0,
			1, 0, 9, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 1, 0, 0, 1, 1, 0,
			0, 1, 0, 0, 0, 9, 0, 0, 0, 1, 0, 0, 0, 9, 1, 0, 0, 1, 1, 0, 1, 1,
			1, 0, 0, 0, 9, 1, 0, 0, 1, 1, 0, 1, 1, 1, 9, 0, 9, 0, 0, 0, 0, 1,
			1, 9, 0, 0, 9, 9, 9, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1,
			1, 0, 1, 0, 1, 1, 0, 9, 0, 1, 9, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1,
			1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0,
			0, 0, 9, 9, 1, 1, 1, 1, 0, 1, 9, 9, 9, 1, 1, 0, 1, 1, 1, 9, 1, 1,
			1, 1, 1, 1, 1, 1 };

	/** the input device */
	private java.io.Reader yy_reader;

	/** the current state of the DFA */
	private int yy_state;

	/** the current lexical state */
	private int yy_lexical_state = YYINITIAL;

	/**
	 * this buffer contains the current text to be matched and is the source of
	 * the yytext() string
	 */
	private char yy_buffer[] = new char[16384];

	/** the textposition at the last accepting state */
	private int yy_markedPos;

	/** the textposition at the last state to be included in yytext */
	private int yy_pushbackPos;

	/** the current text position in the buffer */
	private int yy_currentPos;

	/** startRead marks the beginning of the yytext() string in the buffer */
	private int yy_startRead;

	/**
	 * endRead marks the last character in the buffer, that has been read from
	 * input
	 */
	private int yy_endRead;

	/** number of newlines encountered up to the start of the matched text */
	private int yyline;

	/** the number of characters up to the start of the matched text */
	private int yychar;

	/**
	 * the number of characters from the last newline up to the start of the
	 * matched text
	 */
	// private int yycolumn;

	/**
	 * yy_atBOL == true <=> the scanner is currently at the beginning of a line
	 */
	// private boolean yy_atBOL;

	/** yy_atEOF == true <=> the scanner has returned a value for EOF */
	private boolean yy_atEOF;

	/** denotes if the user-EOF-code has already been executed */
	private boolean yy_eof_done;

	/* user code: */
	// where the last internal container block was found
	private int fLastInternalBlockStart = -1;

	private int fTokenCount = 0;

	// required holders for white-space compacting
	private boolean fShouldLoadBuffered = false;
	private String fBufferedContext = null;
	private String fBufferedText = null;
	private int fBufferedStart = 1;
	private int fBufferedLength = 0;

	// help for php container text region
	private ContextRegionContainer fBufferedEmbeddedContainer = null;
	private String f_context = null;

	// state stack for handling embedded regions
	private IntStack fStateStack = new IntStack();

	// a "hint" as to what an embedded region should be evaluated
	private String fEmbeddedHint = UNDEFINED;
	// a "hint" as to what state to enter once an embedded region has
	// been completed
	private int fEmbeddedPostState = YYINITIAL;
	// the container used to create embedded regions
	private ContextRegionContainer fEmbeddedContainer = null;
	private static final String PROXY_CONTEXT = "PROXY_CONTEXT"; //$NON-NLS-1$

	private String context = null;
	private String text = null;
	private int start = 0;
	private int textLength = 0;
	private int length = 0;

	// offset for tracking position specific block tags
	private int fOffset = 0;

	// the name of the current tag being opened
	private String fCurrentTagName = null;

	// the list of tag name BlockMarkers
	private List fBlockMarkers = new ArrayList();

	// required to not seek text blocks on an end tag
	private boolean fIsBlockingEnabled = false;
	private boolean fIsCaseSensitiveBlocking = true;

	// the name of the current tag inside of an embedded region
	private String internalTagName = null;
	private String internalContext = null;

	private final XMLParserRegionFactory fRegionFactory = new XMLParserRegionFactory();

	/**
	 * user method
	 */
	public final void addBlockMarker(BlockMarker marker) {
		if (containsTagName(marker.getTagName()))
			return;
		fBlockMarkers.add(marker);
	}

	/**
	 * user method
	 */
	public final void removeBlockMarker(BlockMarker marker) {
		fBlockMarkers.remove(marker);
	}

	/**
	 * user method
	 */
	public final void removeBlockMarker(String tagname) {
		if (fBlockMarkers != null) {
			Iterator blocks = fBlockMarkers.iterator();
			while (blocks.hasNext()) {
				if (((BlockMarker) blocks.next()).getTagName().equals(tagname))
					blocks.remove();
			}
		}
	}

	/* user method */
	public boolean getBlockMarkerCaseSensitivity() {
		return getBlockMarkerCaseSensitivity(fCurrentTagName);
	}

	/* user method */
	public boolean getBlockMarkerCaseSensitivity(String name) {
		Iterator iterator = fBlockMarkers.iterator();
		while (iterator.hasNext()) {
			BlockMarker marker = (BlockMarker) iterator.next();
			boolean casesensitive = marker.isCaseSensitive();
			if (casesensitive && marker.getTagName().equals(name))
				return casesensitive;
			else if (!casesensitive
					&& marker.getTagName().equalsIgnoreCase(name))
				return casesensitive;
		}
		return true;
	}

	/* user method */
	public String getBlockMarkerContext() {
		return getBlockMarkerContext(fCurrentTagName);
	}

	/* user method */
	public String getBlockMarkerContext(String name) {
		Iterator iterator = fBlockMarkers.iterator();
		while (iterator.hasNext()) {
			BlockMarker marker = (BlockMarker) iterator.next();
			if (marker.getTagName().equals(name))
				return marker.getContext();
		}
		return BLOCK_TEXT;
	}

	/* user method */
	public List getBlockMarkers() {
		return fBlockMarkers;
	}

	/* user method */
	public final int getOffset() {
		return fOffset + yychar;
	}

	private final boolean isBlockMarker() {
		return isBlockMarker(fCurrentTagName);
	}

	private final boolean isBlockMarker(String tagName) {
		if (!fIsBlockingEnabled)
			return false;
		return containsTagName(tagName);
	}

	/**
	 * user method
	 */
	public final void beginBlockTagScan(String newTagName) {
		beginBlockMarkerScan(newTagName, BLOCK_TEXT);
	}

	/**
	 * user method
	 * 
	 * Special tokenizer setup. Allows tokenization to be initiated at the start
	 * of a text block within a "newTagName" tag.
	 * 
	 * Example: Tokenizer toker = new Tokenizer();
	 * toker.setCaseSensitiveBlocking(false); toker.reset(new
	 * java.io.StringReader
	 * ("afiuhqwkejhtasihgalkwhtq</scripter></scr></script>asgdasga"));
	 * toker.beginBlockMarkerScan("script", BLOCK_TEXT); toker.getRegions();
	 * 
	 * Returns: BLOCK_TEXT: 0-40 XML_END_TAG_OPEN: 41-42 XML_TAG_NAME: 43-48
	 * XML_TAG_CLOSE: 49-49 XML_CONTENT: 50-57
	 * 
	 */
	public final void beginBlockMarkerScan(String newTagName,
			String blockcontext) {
		yybegin(ST_BLOCK_TAG_SCAN);
		fCurrentTagName = newTagName;
	}

	/**
	 * Method doScan.
	 * 
	 * Returns a context region for all of the text from the current position
	 * upto the end of input or to right *before* the first occurence of
	 * searchString
	 * 
	 * @param searchString
	 *            - target string to search for ex.: "-->", "</tagname"
	 * @param requireTailSeparator
	 *            - whether the target must be immediately followed by
	 *            whitespace or '>'
	 * @param context
	 *            - the context of the scanned region if non-zero length
	 * @param exitState
	 *            - the state to go to if the region was of non-zero length
	 * @param abortState
	 *            - the state to go to if the searchString was found immediately
	 * @return String - the context found: the desired context on a non-zero
	 *         length match, the abortContext on immediate success
	 * @throws IOException
	 */
	private final String doScan(String searchString, boolean allowPHP,
			boolean requireTailSeparator, String searchContext, int exitState,
			int immediateFallbackState) throws IOException {
		boolean stillSearching = true;
		// Disable further block (probably)
		fIsBlockingEnabled = false;
		int searchStringLength = searchString.length();
		int n = 0;
		char lastCheckChar;
		int i;
		boolean same = false;
		while (stillSearching) {
			n = 0;
			// Ensure that enough data from the input exists to compare against
			// the search String.
			n = yy_advance();
			while (n != YYEOF && yy_currentPos < searchStringLength)
				n = yy_advance();
			// If the input was too short or we've exhausted the input, stop
			// immediately.
			if (n == YYEOF) {
				stillSearching = false;
			} else {

				/**
				 * Look for starting PHPs "<?"
				 */
				// Look for a PHP beginning at the current position; this case
				// wouldn't be handled by the preceding section
				// since it relies upon *having* closeTagStringLength amount of
				// input to work as designed. Must be sure we don't
				// spill over the end of the buffer while checking.
				if (allowPHP
						&& yy_startRead != fLastInternalBlockStart
						&& yy_currentPos > 0
						&& yy_currentPos < yy_buffer.length - 1
						&& yy_buffer[yy_currentPos - 1] == '<'
						&& (yy_buffer[yy_currentPos] == '?' || (yy_buffer[yy_currentPos] == '%' && ProjectOptions
								.isSupportingAspTags(project)))) {
					fLastInternalBlockStart = yy_markedPos = yy_currentPos - 1;
					yy_currentPos = yy_markedPos + 1;
					int resumeState = yystate();
					yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
					if (yy_markedPos == yy_startRead) {
						String jspContext = primGetNextToken();
						yybegin(resumeState);
						return jspContext;
					}
					return searchContext;
				}

				// 2) yy_currentPos - jspstarter.length : There's not
				// searchStringLength of input available; check for a JSP 2
				// spots back in what we could read
				// ---
				// Look for a JSP beginning at the current position; this case
				// wouldn't be handled by the preceding section
				// since it relies upon *having* closeTagStringLength amount of
				// input to work as designed. Must be sure we don't
				// spill over the end of the buffer while checking.
				else if (allowPHP && yy_startRead != fLastInternalBlockStart
						&& yy_currentPos > 0
						&& yy_currentPos < yy_buffer.length - 1
						&& yy_buffer[yy_currentPos - 1] == '<'
						&& yy_buffer[yy_currentPos] == '?') {
					fLastInternalBlockStart = yy_markedPos = yy_currentPos - 1;
					yy_currentPos = yy_markedPos + 1;
					int resumeState = yystate();
					yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
					if (yy_markedPos == yy_startRead) {
						String jspContext = primGetNextToken();
						yybegin(resumeState);
						return jspContext;
					}
					return searchContext;
				}
				// 3) yy_currentPos..(yy_currentPos+jspStartlength-1) : Check at
				// the start of the block one time
				// ---
				// Look for a JSP beginning immediately in the block area; this
				// case wouldn't be handled by the preceding section
				// since it relies upon yy_currentPos equaling exactly the
				// previous end +1 to work as designed.
				else if (allowPHP && yy_startRead != fLastInternalBlockStart
						&& yy_startRead > 0
						&& yy_startRead < yy_buffer.length - 1
						&& yy_buffer[yy_startRead] == '<'
						&& yy_buffer[yy_startRead + 1] == '?') {
					fLastInternalBlockStart = yy_markedPos = yy_startRead;
					yy_currentPos = yy_markedPos + 1;
					int resumeState = yystate();
					yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
					if (yy_markedPos == yy_startRead) {
						String jspContext = primGetNextToken();
						yybegin(resumeState);
						return jspContext;
					}
					return searchContext;
				}

				// Check the characters in the target versus the last
				// targetLength characters read from the buffer
				// and see if it matches
				if (n == YYEOF) {
					stillSearching = false;
				} else {
					same = true;
					// Ensure that we've not encountered a complete block (<%%>)
					// that was *shorter* than the closeTagString and
					// thus found twice at current-targetLength [since the first
					// scan would have come out this far anyway].
					// Check the characters in the target versus the last
					// targetLength characters read from the buffer
					// and see if it matches

					// safety check for array accesses (yy_currentPos is the
					// *last* character we can check against)
					if (yy_currentPos >= searchStringLength
							&& yy_currentPos <= yy_buffer.length) {
						for (i = 0; i < searchStringLength; i++) {
							if (same && fIsCaseSensitiveBlocking)
								same = yy_buffer[i + yy_currentPos
										- searchStringLength] == searchString
										.charAt(i);
							else if (same && !fIsCaseSensitiveBlocking)
								same = Character.toLowerCase(yy_buffer[i
										+ yy_currentPos - searchStringLength]) == Character
										.toLowerCase(searchString.charAt(i));
						}
					}
					// safety check failed; no match is possible right now
					else {
						same = false;
					}
				}
				if (same && requireTailSeparator
						&& yy_currentPos < yy_buffer.length) {
					// Additional check for close tags to ensure that
					// targetString="</script" doesn't match
					// "</scriptS"
					lastCheckChar = yy_buffer[yy_currentPos];
					// Succeed on "</script>" and "</script "
					if (lastCheckChar == '>'
							|| Character.isWhitespace(lastCheckChar))
						stillSearching = false;
				} else {
					stillSearching = !same
							|| (yy_currentPos < yy_startRead
									+ searchStringLength);
				}
			}
		}
		if (n != YYEOF || same) {
			// We've stopped short of the end or definitely found a match
			yy_markedPos = yy_currentPos - searchStringLength;
			yy_currentPos = yy_markedPos + 1;
			// If the searchString occurs at the very beginning of what would
			// have
			// been a Block, resume scanning normally immediately
			if (yy_markedPos == yy_startRead) {
				yybegin(immediateFallbackState);
				return primGetNextToken();
			}
		} else {
			// We ran through the rest of the input
			yy_markedPos = yy_currentPos;
			yy_currentPos++;
		}
		yybegin(exitState);
		// If the ending occurs at the very beginning of what would have
		// been a Block, resume scanning normally immediately
		if (yy_markedPos == yy_startRead)
			return primGetNextToken();
		return searchContext;
	}

	/**
	 * Method doScanEndPhp
	 * 
	 * @see doScan(searchString, req...) this version can handle two strings as
	 *      options to search string it originally written to support ?> or %>
	 *      close tags to php The two strings must be on the same length
	 * 
	 * @param isAsp
	 *            - whether the asp %> close is premited
	 * @param context
	 *            - the context of the scanned region if non-zero length
	 * @param exitState
	 *            - the state to go to if the region was of non-zero length
	 * @param abortState
	 *            - the state to go to if the searchString was found immediately
	 * @return String - the context found: the desired context on a non-zero
	 *         length match, the abortContext on immediate success
	 * @throws IOException
	 */
	private ITextRegion bufferedTextRegion = null;

	private final String doScanEndPhp(boolean isAsp, String searchContext,
			int exitState, int immediateFallbackState) throws IOException {
		yypushback(1); // begin with the last char

		final AbstractPhpLexer phpLexer = getPhpLexer();
		bufferedTextRegion = new PhpScriptRegion(searchContext, yychar,
				project, phpLexer);

		// restore the locations / states
		reset(yy_reader, phpLexer.getZZBuffer(), phpLexer.getParamenters());

		yybegin(exitState);
		return searchContext;
	}

	/**
	 * @param project
	 * @param stream
	 * @return a new lexer for the given project with the given stream
	 *         initialized with current parameters
	 */
	private AbstractPhpLexer getPhpLexer() {
		final PHPVersion phpVersion = ProjectOptions.getPhpVersion(project);
		final AbstractPhpLexer lexer = PhpLexerFactory.createLexer(yy_reader,
				phpVersion);
		int[] currentParameters = getParamenters();
		try {
			// set initial lexer state - we use reflection here since we don't
			// know the constant value of
			// of this state in specific PHP version lexer
			currentParameters[6] = lexer.getClass()
					.getField("ST_PHP_IN_SCRIPTING").getInt(lexer); //$NON-NLS-1$
		} catch (Exception e) {
			Logger.logException(e);
		}
		lexer.initialize(currentParameters[6]);
		lexer.reset(yy_reader, yy_buffer, currentParameters);
		lexer.setPatterns(project);

		lexer.setAspTags(ProjectOptions.isSupportingAspTags(project));
		return lexer;
	}

	// call the doScan without searching for PHP internal code
	private final String doScan(String searchString,
			boolean requireTailSeparator, String searchContext, int exitState,
			int immediateFallbackState) throws IOException {
		return doScan(searchString, true, requireTailSeparator, searchContext,
				exitState, immediateFallbackState);
	}

	/* user method */
	private final void assembleEmbeddedTagSequence(String startType,
			String endTagName) {
		assembleEmbeddedContainer(startType, null, endTagName);
	}

	/* user method */
	private final void assembleEmbeddedContainer(String startType,
			String[] endTypes) {
		assembleEmbeddedContainer(startType, endTypes, null);
	}

	/* user method */
	private final void assembleEmbeddedContainer(String startType,
			String endType) {
		assembleEmbeddedContainer(startType, new String[] { endType }, null);
	}

	/**
	 * user method
	 * 
	 * Assembles an embedded container beginning with the given startType as the
	 * first ContextRegion within it and of the type fEmbeddedHint. The
	 * endTypes[] array contains the context types that will cause a successful
	 * exit. Use of the endTagName parameter alters this behavior to force an
	 * exit on an XML_TAG_CLOSE after seeing an XML_TAG_NAME whose significant
	 * text matches the endTagName String. All contents in between are
	 * insignificant, and yes, this means comments are allowed inside.
	 **/
	private final void assembleEmbeddedContainer(String startType,
			String[] endTypes, String endTagName) {
		// the context of the region being added to the embedded container
		internalContext = startType;
		// keep track of where this container began; to provide relative indeces
		// for the regions
		int containerStart = yychar;
		boolean notFinished = true;
		// keep track of where we seem to be so that the endTagName can be
		// checked
		boolean isInEndTag = false;
		boolean isInFirstTag = true;
		// create the embedded container and setup its "type"
		if (fEmbeddedContainer == null) {
			fEmbeddedContainer = new ContextRegionContainer();
			fEmbeddedContainer.setType(fEmbeddedHint);
			fEmbeddedContainer.setStart(containerStart);
			// TODO: parent region needs to be set .... but not sure where to
			// get it from
			// fEmbeddedContainer.setParent(parentRegion);
		}
		containerStart = fEmbeddedContainer.getStart();
		while (notFinished) {
			// add the region to the container
			if (internalContext != null && internalContext != PROXY_CONTEXT) {

				ITextRegion newToken;
				// if it is php content we extract the tokens
				if (internalContext == PHP_CONTENT) {
					newToken = bufferedTextRegion;
					bufferedTextRegion.adjustStart(-containerStart);
				} else {
					newToken = fRegionFactory.createToken(internalContext,
							yychar - containerStart, yylength(), yylength());
				}
				fEmbeddedContainer.getRegions().add(newToken);
				fEmbeddedContainer.setLength(fEmbeddedContainer.getLength()
						+ newToken.getLength());
				fEmbeddedContainer.setTextLength(fEmbeddedContainer
						.getTextLength() + newToken.getLength());
				// DW, 4/16/2003 token regions no longer have parents
				// newToken.setParent(fEmbeddedContainer);
			}
			try {
				// longscan determines whether to attempt a blockTagScan within
				// the embedded container
				boolean longscan = false;
				// save the tokenizer state in case of a block tag scan
				int previousState = yystate();
				String previousCurrentTagName = fCurrentTagName;
				int previousPostState = fEmbeddedPostState;
				String previousEmbeddedHint = fEmbeddedHint;
				// determine if a block tag scan is necessary
				if (internalContext == XML_TAG_NAME) {
					internalTagName = yytext();
					if (!isNestable(internalTagName)) {
						internalTagName = null;
						// snagged a tag name we shouldn't have
						fEmbeddedPostState = ST_ABORT_EMBEDDED;
						notFinished = false;
					}
				} else if (internalContext == XML_TAG_OPEN
						|| internalContext == XML_END_TAG_OPEN) {
					internalTagName = null;
				}
				// do upkeep for endTagName usage; must be here since the next
				// token could be the close
				if (internalContext == XML_END_TAG_OPEN) {
					isInEndTag = true;
				} else if (internalContext == XML_TAG_CLOSE) {
					isInFirstTag = isInEndTag = false;
				} else {
					ITextRegionList embeddedRegions = fEmbeddedContainer
							.getRegions();
					if (embeddedRegions.size() > 2
							&& (embeddedRegions.get(embeddedRegions.size() - 1))
									.getType() == XML_TAG_CLOSE
							&& (embeddedRegions.get(embeddedRegions.size() - 3))
									.getType() == XML_TAG_OPEN
							&& internalTagName != null) {
						if (containsTagName(internalTagName)) {
							longscan = true;
							yybegin(ST_BLOCK_TAG_SCAN);
						}
					}
				}
				if (longscan)
					fCurrentTagName = internalTagName;
				// read the next region and context
				internalContext = primGetNextToken();
				if (longscan) {
					// Returning from a block tag scan requires restoring some
					// state variables
					// as well as handling the block region and setting up for
					// normal scanning
					// inside the embedded container

					ITextRegion newToken;
					// if it is php content we extract the tokens
					if (internalContext == PHP_CONTENT) {
						newToken = bufferedTextRegion;
						bufferedTextRegion.adjustStart(-containerStart);
					} else {
						newToken = fRegionFactory
								.createToken(internalContext, yychar
										- containerStart, yylength(),
										yylength());
					}

					fEmbeddedContainer.getRegions().add(newToken);
					fEmbeddedContainer.setLength(fEmbeddedContainer.getLength()
							+ newToken.getLength());
					fEmbeddedContainer.setTextLength(fEmbeddedContainer
							.getTextLength() + newToken.getLength());
					// DW, 4/16/2003 token regions no longer have parents
					// newToken.setParent(fEmbeddedContainer);
					longscan = false;
					fEmbeddedPostState = previousPostState;
					fEmbeddedHint = previousEmbeddedHint;
					fCurrentTagName = previousCurrentTagName;
					yybegin(previousState);
					internalContext = primGetNextToken();
				}
			} catch (IOException e) {
				// primGetNextToken() calls may throw an IOException
				// catch and do nothing since the isEOF check below
				// will properly exit if the input was too short
			} catch (Exception f) {
				// some other exception happened; never should
				Logger.logException(f);
			}
			boolean isEndingType = yystate() == ST_ABORT_EMBEDDED;
			if (!isEndingType) {
				// check for ending context
				if (endTagName == null) {
					for (int i = 0; i < endTypes.length; i++) {
						isEndingType = isEndingType
								|| (internalContext == endTypes[i]);
					}
				} else {
					isEndingType = ((isInEndTag && internalContext == XML_TAG_CLOSE) || (isInFirstTag && internalContext == XML_EMPTY_TAG_CLOSE))
							&& internalTagName != null
							&& internalTagName.equals(endTagName);
				}
			}
			ITextRegionList embeddedList = fEmbeddedContainer.getRegions();
			notFinished = notFinished
					&& ((!isEndingType)
							&& !isEOF()
							&& (endTagName != null || internalContext != UNDEFINED) && !(internalContext == PROXY_CONTEXT && (embeddedList
							.get(embeddedList.size() - 1)).getType() == UNDEFINED));
		}
		// finish adding the last context
		if (internalContext != null && internalContext != PROXY_CONTEXT) {
			ITextRegion newToken = fRegionFactory.createToken(internalContext,
					yychar - containerStart, yylength(), yylength());
			fEmbeddedContainer.getRegions().add(newToken);
			// DW, 4/16/2003 token regions no longer have parents
			// newToken.setParent(fEmbeddedContainer);
			fEmbeddedContainer.setLength(yychar - containerStart + yylength());
			fEmbeddedContainer.setTextLength(yychar - containerStart
					+ yylength());
		}
		yybegin(fEmbeddedPostState);
	}

	/**
	 * user method
	 */
	private boolean isNestable(String tagName) {
		return false; // true is for jsp
	}

	/**
	 * user method
	 * 
	 * A generic lookahead-like operation
	 */
	private final String doBlockScan(String target, String targetContext,
			int immediateFallbackState) throws IOException {
		return doScan(target, false, targetContext, immediateFallbackState,
				immediateFallbackState);
	}

	/**
	 * user method does a lookahead for the current tag name
	 */
	private final String doBlockTagScan() throws IOException {
		fIsCaseSensitiveBlocking = getBlockMarkerCaseSensitivity();
		return doScan(
				"</" + fCurrentTagName, true, getBlockMarkerContext(fCurrentTagName), YYINITIAL, YYINITIAL); //$NON-NLS-1$
	}

	private IProject project;

	public void setProject(IProject project) {
		this.project = project;
	}

	public void reset(java.io.Reader reader, char[] buffer, int[] parameters) {
		this.yy_reader = reader;
		this.yy_buffer = buffer;
		this.yy_markedPos = parameters[0];
		this.yy_pushbackPos = parameters[1];
		this.yy_currentPos = parameters[2];
		this.yy_startRead = parameters[3];
		this.yy_endRead = parameters[4];
		this.yyline = parameters[5];
		this.yychar = this.yy_startRead - this.yy_pushbackPos;
	}

	public int[] getParamenters() {
		return new int[] { yy_markedPos, yy_pushbackPos, yy_currentPos,
				yy_startRead, yy_endRead, yyline, yy_lexical_state };
	}

	/**
	 * user method
	 * 
	 * Converts the raw context String returned by the primGetNextToken() method
	 * into a full ITextRegion by pulling in values for the current offset
	 * within the scanning text.
	 * 
	 * Returns null when EOF is encountered and attaches intermittently
	 * discovered whitespace onto the end of useful regions.
	 * 
	 * Note that this algorithm caches the token following the one being
	 * returned so that whitespace can be collapsed.
	 */
	public final ITextRegion getNextToken() throws IOException {
		fEmbeddedContainer = null;
		// load the starting non-whitespace token (assume that it is so)
		if (fShouldLoadBuffered) {
			if (fBufferedEmbeddedContainer != null) {
				ITextRegion container = fBufferedEmbeddedContainer;
				fBufferedEmbeddedContainer = null;
				fShouldLoadBuffered = false;
				return container;
			}
			context = fBufferedContext;
			text = fBufferedText;
			start = fBufferedStart;
			textLength = length = fBufferedLength;
			fShouldLoadBuffered = false;
		} else {
			context = primGetNextToken();
			if (context == PROXY_CONTEXT) {
				return fEmbeddedContainer;
			} else if (context == XML_TAG_OPEN) {
				fIsBlockingEnabled = true;
			} else if (context == XML_END_TAG_OPEN) {
				fIsBlockingEnabled = false;
			}
			text = yytext();
			if (context == XML_TAG_NAME) {
				if (containsTagName(yy_buffer, yy_startRead, yy_markedPos
						- yy_startRead))
					fCurrentTagName = text;
				else
					fCurrentTagName = null;
			} else if (context == XML_TAG_OPEN) {
				fIsBlockingEnabled = true;
			} else if (context == XML_END_TAG_OPEN) {
				fIsBlockingEnabled = false;
			}
			start = yychar;
			textLength = length = yylength();
			if (yy_atEOF) {
				fTokenCount++;
				return null;
			}
		}

		// store the next token
		f_context = primGetNextToken();
		if (f_context == PROXY_CONTEXT) {
			fBufferedEmbeddedContainer = fEmbeddedContainer;
			fShouldLoadBuffered = true;
		} else if (f_context == XML_TAG_NAME) {
			if (containsTagName(yy_buffer, yy_startRead, yy_markedPos
					- yy_startRead))
				fCurrentTagName = yytext();
			else
				fCurrentTagName = null;
		} else if (f_context == XML_TAG_OPEN) {
			fIsBlockingEnabled = true;
		} else if (f_context == XML_END_TAG_OPEN) {
			fIsBlockingEnabled = false;
		}
		fBufferedContext = f_context;
		fBufferedText = yytext();
		if (fBufferedContext == XML_TAG_NAME) {
			if (containsTagName(yy_buffer, yy_startRead, yy_markedPos
					- yy_startRead))
				fCurrentTagName = fBufferedText;
			else
				fCurrentTagName = null;
		} else if (fBufferedContext == XML_TAG_OPEN) {
			fIsBlockingEnabled = true;
		} else if (fBufferedContext == XML_END_TAG_OPEN) {
			fIsBlockingEnabled = false;
		}
		fBufferedStart = yychar;
		fBufferedLength = yylength();
		if (fBufferedContext == WHITE_SPACE) {
			fShouldLoadBuffered = false;
			length += fBufferedLength;
		} else {
			fShouldLoadBuffered = true;
		}
		if (context == null) {
			// EOF
			if (Debug.debugTokenizer) {
				System.out.println(getClass().getName()
						+ " discovered " + fTokenCount + " tokens."); //$NON-NLS-2$//$NON-NLS-1$
			}
			return null;
		}
		fTokenCount++;

		// if it is php content we extract the tokens
		if (context == PHP_CONTENT) {
			return bufferedTextRegion;
		} else {
			return fRegionFactory.createToken(context, start, textLength,
					length, null, fCurrentTagName);
		}
	}

	/* user method */
	public PHPTokenizer() {
		super();
	}

	/* user method */
	public PHPTokenizer(char[] charArray) {
		this(new CharArrayReader(charArray));
	}

	/* user method */
	public void reset(char[] charArray) {
		reset(new CharArrayReader(charArray), 0);
	}

	/* user method */
	public void reset(char[] charArray, int newOffset) {
		reset(new CharArrayReader(charArray), newOffset);
	}

	/* user method */
	public void reset(java.io.InputStream in) {
		reset(new java.io.InputStreamReader(in), 0);
	}

	/* user method */
	public void reset(java.io.InputStream in, int newOffset) {
		reset(new java.io.InputStreamReader(in), newOffset);
	}

	/* user method */
	public void reset(java.io.Reader in) {
		reset(in, 0);
	}

	/**
	 * user method *
	 * 
	 * Reset internal counters and vars to "newly created" values, in the hopes
	 * that resetting a pre-existing tokenizer is faster than creating a new
	 * one.
	 * 
	 * This method contains code blocks that were essentially duplicated from
	 * the <em>generated</em> output of this specification before this method
	 * was added. Those code blocks were under the above copyright.
	 */
	public void reset(java.io.Reader in, int newOffset) {
		if (Debug.debugTokenizer) {
			System.out.println("resetting tokenizer");//$NON-NLS-1$
		}
		fOffset = newOffset;

		/* the input device */
		yy_reader = in;

		/* the current state of the DFA */
		yy_state = 0;

		/* the current lexical state */
		yy_lexical_state = YYINITIAL;

		/*
		 * this buffer contains the current text to be matched and is the source
		 * of the yytext() string
		 */
		java.util.Arrays.fill(yy_buffer, (char) 0);

		/* the textposition at the last accepting state */
		yy_markedPos = 0;

		/* the textposition at the last state to be included in yytext */
		yy_pushbackPos = 0;

		/* the current text position in the buffer */
		yy_currentPos = 0;

		/* startRead marks the beginning of the yytext() string in the buffer */
		yy_startRead = 0;

		/**
		 * endRead marks the last character in the buffer, that has been read
		 * from input
		 */
		yy_endRead = 0;

		/* number of newlines encountered up to the start of the matched text */
		yyline = 0;

		/* the number of characters up to the start of the matched text */
		yychar = 0;

		/* yy_atEOF == true <=> the scanner has returned a value for EOF */
		yy_atEOF = false;

		/* denotes if the user-EOF-code has already been executed */
		yy_eof_done = false;

		/* user vars: */
		fLastInternalBlockStart = -1;

		fTokenCount = 0;

		fShouldLoadBuffered = false;
		fBufferedContext = null;
		fBufferedText = null;
		fBufferedStart = 1;
		fBufferedLength = 0;
		fStateStack = new IntStack();

		context = null;
		text = null;
		start = 0;
		textLength = 0;
		length = 0;
	}

	/**
	 * user method
	 * 
	 */
	public BlockTokenizer newInstance() {
		PHPTokenizer newInstance = new PHPTokenizer();
		// global tagmarkers can be shared; they have no state and
		// are never destroyed (e.g. 'release')
		for (int i = 0; i < fBlockMarkers.size(); i++) {
			BlockMarker blockMarker = (BlockMarker) fBlockMarkers.get(i);
			if (blockMarker.isGlobal())
				newInstance.addBlockMarker(blockMarker);
		}
		return newInstance;
	}

	/* user method */
	private final String scanXMLCommentText() throws IOException {
		// Scan for '-->' and return the text up to that point as
		// XML_COMMENT_TEXT unless the string occurs IMMEDIATELY, in which
		// case change to the ST_XML_COMMENT_END state and return the next
		// context as usual.
		return doScan(
				"-->", true, false, XML_COMMENT_TEXT, ST_XML_COMMENT_END, ST_XML_COMMENT_END); //$NON-NLS-1$
	}

	/**
	 * Creates a new scanner There is also a java.io.InputStream version of this
	 * constructor.
	 * 
	 * @param in
	 *            the java.io.Reader to read input from.
	 */
	public PHPTokenizer(java.io.Reader in) {
		this.yy_reader = in;
	}

	/**
	 * Creates a new scanner. There is also java.io.Reader version of this
	 * constructor.
	 * 
	 * @param in
	 *            the java.io.Inputstream to read input from.
	 */
	public PHPTokenizer(java.io.InputStream in) {
		this(new java.io.InputStreamReader(in));
	}

	/**
	 * Unpacks the compressed DFA transition table.
	 * 
	 * @param packed
	 *            the packed transition table
	 * @return the unpacked transition table
	 */
	private static int[] yy_unpack(String packed) {
		int[] trans = new int[12921];
		int i = 0; /* index in packed string */
		int j = 0; /* index in unpacked array */
		while (i < 3894) {
			int count = packed.charAt(i++);
			int value = packed.charAt(i++);
			value--;
			do
				trans[j++] = value;
			while (--count > 0);
		}
		return trans;
	}

	/**
	 * Unpacks the compressed character translation table.
	 * 
	 * @param packed
	 *            the packed character translation table
	 * @return the unpacked character translation table
	 */
	private static char[] yy_unpack_cmap(String packed) {
		char[] map = new char[0x10000];
		int i = 0; /* index in packed string */
		int j = 0; /* index in unpacked array */
		while (i < 1372) {
			int count = packed.charAt(i++);
			char value = packed.charAt(i++);
			do
				map[j++] = value;
			while (--count > 0);
		}
		return map;
	}

	/**
	 * Gets the next input character.
	 * 
	 * @return the next character of the input stream, EOF if the end of the
	 *         stream is reached.
	 * @exception IOException
	 *                if any I/O-Error occurs
	 */
	private int yy_advance() throws java.io.IOException {

		/* standard case */
		if (yy_currentPos < yy_endRead)
			return yy_buffer[yy_currentPos++];

		/* if the eof is reached, we don't need to work hard */
		if (yy_atEOF)
			return YYEOF;

		/* otherwise: need to refill the buffer */

		/* first: make room (if you can) */
		if (yy_startRead > 0) {
			System.arraycopy(yy_buffer, yy_startRead, yy_buffer, 0, yy_endRead
					- yy_startRead);

			/* translate stored positions */
			yy_endRead -= yy_startRead;
			yy_currentPos -= yy_startRead;
			yy_markedPos -= yy_startRead;
			yy_pushbackPos -= yy_startRead;
			yy_startRead = 0;
		}

		/* is the buffer big enough? */
		if (yy_currentPos >= yy_buffer.length) {
			/* if not: blow it up */
			char newBuffer[] = new char[yy_currentPos * 2];
			System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
			yy_buffer = newBuffer;
		}

		/* finally: fill the buffer with new input */
		int numRead = yy_reader.read(yy_buffer, yy_endRead, yy_buffer.length
				- yy_endRead);

		if (numRead == -1)
			return YYEOF;

		yy_endRead += numRead;

		return yy_buffer[yy_currentPos++];
	}

	/**
	 * Closes the input stream.
	 */
	final public void yyclose() throws java.io.IOException {
		yy_atEOF = true; /* indicate end of file */
		yy_endRead = yy_startRead; /* invalidate buffer */
		yy_reader.close();
	}

	/**
	 * Returns the current lexical state.
	 */
	final public int yystate() {
		return yy_lexical_state;
	}

	/**
	 * Enters a new lexical state
	 * 
	 * @param newState
	 *            the new lexical state
	 */
	final public void yybegin(int newState) {
		yy_lexical_state = newState;
	}

	/**
	 * Returns the text matched by the current regular expression.
	 */
	final public String yytext() {
		return new String(yy_buffer, yy_startRead, yy_markedPos - yy_startRead);
	}

	/**
	 * Returns the length of the matched text region.
	 */
	final public int yylength() {
		return yy_markedPos - yy_startRead;
	}

	/**
	 * Reports an error that occured while scanning - from the SED JFlex
	 * skeleton
	 * 
	 * @param errorCode
	 *            the code of the errormessage to display
	 */
	private void yy_ScanError(int errorCode) {
		try {
			Logger.log(Logger.ERROR, YY_ERROR_MSG[errorCode]);
		} catch (ArrayIndexOutOfBoundsException e) {
			Logger.log(Logger.ERROR, YY_ERROR_MSG[YY_UNKNOWN_ERROR]);
		}
		// DO NOT EXIT the VM on an error
		// System.exit(1);
	}

	/**
	 * Pushes the specified amount of characters back into the input stream.
	 * 
	 * They will be read again by then next call of the scanning method
	 * 
	 * @param number
	 *            the number of characters to be read again. This number must
	 *            not be greater than yylength()!
	 */
	void yypushback(int number) {
		if (number > yylength())
			yy_ScanError(YY_PUSHBACK_2BIG);

		yy_markedPos -= number;
	}

	/**
	 * user method - skeleton.sed
	 */
	protected final boolean containsTagName(char[] markerTagName, int offset,
			int tagnameLength) {
		for (int j = 0; j < fBlockMarkers.size(); j++) {
			BlockMarker marker = (BlockMarker) fBlockMarkers.get(j);
			if (marker.getTagName().length() == tagnameLength) {
				boolean matchesSoFar = true;
				for (int i = 0; i < tagnameLength && matchesSoFar; i++) {
					if (marker.isCaseSensitive()) {
						if (marker.getTagName().charAt(i) != markerTagName[i
								+ offset])
							matchesSoFar = false;
					} else {
						if (Character
								.toLowerCase(marker.getTagName().charAt(i)) != Character
								.toLowerCase(markerTagName[i + offset]))
							matchesSoFar = false;
					}
				}
				if (matchesSoFar)
					return true;
			}
		}
		return false;
	}

	/**
	 * user method - skeleton.sed
	 * 
	 * Return ALL of the regions scannable within the remaining text Note: for
	 * verification use
	 */
	public final List getRegions() {
		List tokens = new ArrayList();
		ITextRegion region = null;
		try {
			region = getNextToken();
			while (region != null) {
				if (region != null) {
					tokens.add(region);
				}
				region = getNextToken();
			}
		} catch (StackOverflowError e) {
			Logger.logException(
					getClass().getName()
							+ ": input could not be tokenized correctly at position " + getOffset(), e);//$NON-NLS-1$
			throw e;
		} catch (Exception e) {
			// Since this is convenience method and NOT the recommended
			// way of getting tokens, many errors are simply hidden
			Logger.logException(
					"Exception not handled retrieving regions: " + e.getLocalizedMessage(), e);//$NON-NLS-1$
		}
		return tokens;
	}

	/**
	 * user method - skeleton.sed
	 */
	private final void dump(String s) {
		if (Debug.debugTokenizer) {
			System.out.println(s + " (" + yychar + "-" + //$NON-NLS-2$//$NON-NLS-1$
					(yylength() + yychar) + "):\'" + //$NON-NLS-1$
					StringUtils.escape(yytext()) + "\'");//$NON-NLS-1$
		}
	}

	/* user method - skeleton.sed */
	public final boolean isEOF() {
		return yy_atEOF;
	}

	/* user method - skeleton.sed */
	protected final boolean containsTagName(String markerTagName) {
		Iterator blocks = fBlockMarkers.iterator();
		while (blocks.hasNext()) {
			BlockMarker marker = (BlockMarker) blocks.next();
			if (marker.isCaseSensitive()) {
				if (marker.getTagName().equals(markerTagName))
					return true;
			} else {
				if (marker.getTagName().equalsIgnoreCase(markerTagName))
					return true;
			}
		}
		return false;
	}

	/**
	 * Contains user EOF-code, which will be executed exactly once, when the end
	 * of file is reached
	 */
	private void yy_do_eof() {
		if (!yy_eof_done) {
			yy_eof_done = true;
			// do nothing, this is the downstream parser's job

		}
	}

	/**
	 * Resumes scanning until the next regular expression is matched, the end of
	 * input is encountered or an I/O-Error occurs.
	 * 
	 * @return the next token
	 * @exception IOException
	 *                if any I/O-Error occurs
	 */
	public String primGetNextToken() throws java.io.IOException {
		int yy_input;
		int yy_action;

		while (true) {

			yychar += yylength();

			boolean yy_counted = false;
			for (yy_currentPos = yy_startRead; yy_currentPos < yy_markedPos; yy_currentPos++) {
				switch (yy_buffer[yy_currentPos]) {
				case '\r':
					yyline++;
					yy_counted = true;
					break;
				case '\n':
					if (yy_counted)
						yy_counted = false;
					else {
						yyline++;
					}
					break;
				default:
					yy_counted = false;
				}
			}

			if (yy_counted) {
				if (yy_advance() == '\n')
					yyline--;
				if (!yy_atEOF)
					yy_currentPos--;
			}

			yy_action = -1;

			yy_currentPos = yy_startRead = yy_markedPos;

			yy_state = yy_lexical_state;

			yy_forAction: {
				while (true) {

					yy_input = yy_advance();

					if (yy_input == YYEOF)
						break yy_forAction;

					int yy_next = yytrans[yy_rowMap[yy_state]
							+ yycmap[yy_input]];
					if (yy_next == -1)
						break yy_forAction;
					yy_state = yy_next;

					int yy_attributes = YY_ATTRIBUTE[yy_state];
					if ((yy_attributes & 1) > 0) {
						yy_action = yy_state;
						yy_markedPos = yy_currentPos;
						if ((yy_attributes & 8) > 0)
							break yy_forAction;
					}

				}
			}

			switch (yy_action) {

			case 323: {
				if (Debug.debugTokenizer)
					dump("XSL processing instruction target");//$NON-NLS-1$
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_PI_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 325:
				break;
			case 315:
			case 317:
			case 318: {
				if (Debug.debugTokenizer)
					dump("\nCDATA start");//$NON-NLS-1$
				fStateStack.push(yystate());
				yybegin(ST_CDATA_TEXT);
				return XML_CDATA_OPEN;
			}
			case 326:
				break;
			case 308: {
				if (Debug.debugTokenizer)
					dump("element");//$NON-NLS-1$
				yybegin(ST_XML_ELEMENT_DECLARATION);
				return XML_ELEMENT_DECLARATION;
			}
			case 327:
				break;
			case 307: {
				if (Debug.debugTokenizer)
					dump("attlist");//$NON-NLS-1$
				yybegin(ST_XML_ATTLIST_DECLARATION);
				return XML_ATTLIST_DECLARATION;
			}
			case 328:
				break;
			case 306: {
				if (Debug.debugTokenizer)
					dump("doctype");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_DECLARATION);
				return XML_DOCTYPE_DECLARATION;
			}
			case 329:
				break;
			case 299: {
				if (Debug.debugTokenizer)
					dump("doctype external id");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_ID_PUBLIC);
				return XML_DOCTYPE_EXTERNAL_ID_PUBLIC;
			}
			case 330:
				break;
			case 298: {
				if (Debug.debugTokenizer)
					dump("doctype external id");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_ID_SYSTEM);
				return XML_DOCTYPE_EXTERNAL_ID_SYSTEM;
			}
			case 331:
				break;
			case 294: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction target");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_DHTML_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 332:
				break;
			case 262: {
				if (Debug.debugTokenizer)
					dump("\nCharRef");//$NON-NLS-1$
				return XML_CHAR_REFERENCE;
			}
			case 333:
				break;
			case 259: {
				if (Debug.debugTokenizer)
					dump("\ncomment start");//$NON-NLS-1$
				fEmbeddedHint = XML_COMMENT_TEXT;
				fEmbeddedPostState = ST_XML_COMMENT;
				yybegin(ST_XML_COMMENT);
				return XML_COMMENT_OPEN;
			}
			case 334:
				break;
			case 237:
			case 238: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction target");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_PI_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 335:
				break;
			case 236: {
				if (Debug.debugTokenizer)
					dump("comment end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_COMMENT_CLOSE;
			}
			case 336:
				break;
			case 235: {
				if (Debug.debugTokenizer)
					dump("CDATA end");//$NON-NLS-1$
				yybegin(fStateStack.pop());
				return XML_CDATA_CLOSE;
			}
			case 337:
				break;
			case 234: {
				if (Debug.debugTokenizer)
					dump("\nPEReference");//$NON-NLS-1$
				return XML_PE_REFERENCE;
			}
			case 338:
				break;
			case 231: {
				if (Debug.debugTokenizer)
					dump("\nEntityRef");//$NON-NLS-1$
				return XML_ENTITY_REFERENCE;
			}
			case 339:
				break;
			case 224: {
				// begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
				int incomingState = yystate();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				// Php attribute value start - end tag
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedContainer(XML_END_TAG_OPEN, new String[] {
						XML_TAG_CLOSE, XML_EMPTY_TAG_CLOSE });
				if (yystate() != ST_ABORT_EMBEDDED)
					yybegin(incomingState);
				return PROXY_CONTEXT;
			}
			case 340:
				break;
			case 222: {
				yybegin(fStateStack.pop());
				return PHP_CLOSE;

			}
			case 341:
				break;
			case 173:
			case 187:
			case 195: {
				return XML_DOCTYPE_INTERNAL_SUBSET;
			}
			case 342:
				break;
			case 164: {
				String tagName = yytext().substring(1);
				// pushback to just after the opening bracket
				yypushback(yylength() - 1);
				/*
				 * If this tag can not be nested or we're already searching for
				 * an attribute name, equals, or value, return immediately.
				 */
				if (!isNestable(tagName)
						|| (!fStateStack.empty() && (fStateStack.peek() == ST_XML_ATTRIBUTE_NAME
								|| fStateStack.peek() == ST_XML_EQUALS || fStateStack
								.peek() == ST_XML_ATTRIBUTE_VALUE))) {
					yybegin(ST_XML_TAG_NAME);
					return XML_TAG_OPEN;
				}
				if (Debug.debugTokenizer)
					dump("tag in place of attr value");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				fStateStack.push(yystate());
				// embedded container should be looking for the name (again)
				// next
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedTagSequence(XML_TAG_OPEN, tagName); // ?
				fStateStack.pop();
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return PROXY_CONTEXT;
			}
			case 343:
				break;
			case 162: {
				String tagName = yytext().substring(1);
				// pushback to just after the opening bracket
				yypushback(yylength() - 1);
				/*
				 * If this tag can not be nested or we're already searching for
				 * an attribute name, equals, or value, return immediately.
				 */
				if (!isNestable(tagName)
						|| (!fStateStack.empty() && (fStateStack.peek() == ST_XML_ATTRIBUTE_NAME
								|| fStateStack.peek() == ST_XML_EQUALS || fStateStack
								.peek() == ST_XML_ATTRIBUTE_VALUE))) {
					yybegin(ST_XML_TAG_NAME);
					return XML_TAG_OPEN;
				}
				if (Debug.debugTokenizer)
					dump("tag in place of attr name");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				fStateStack.push(yystate());
				// embedded container should be looking for the name (again)
				// next
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedTagSequence(XML_TAG_OPEN, tagName); // ?
				fStateStack.pop();
				yybegin(ST_XML_EQUALS);
				return PROXY_CONTEXT;
			}
			case 344:
				break;
			case 161: {
				yybegin(YYINITIAL);
				fEmbeddedHint = UNDEFINED;
				// empty tag close
				return XML_EMPTY_TAG_CLOSE;
			}
			case 345:
				break;
			case 148: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 346:
				break;
			case 147: {
				// ended with nothing inside
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 347:
				break;
			case 143: {
				if (Debug.debugTokenizer)
					dump("processing instruction end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 348:
				break;
			case 135: {
				fStateStack.push(yystate());
				if (Debug.debugTokenizer)
					dump("\ndeclaration start");//$NON-NLS-1$
				yybegin(ST_XML_DECLARATION);
				return XML_DECLARATION_OPEN;
			}
			case 349:
				break;
			case 133:
			case 134:
			case 206:
			case 207:
			case 219:
			case 220:
			case 291:
			case 300:
			case 302: {
				if (Debug.debugTokenizer)
					dump("\nprocessing instruction start");//$NON-NLS-1$
				if ("<%".equals(yytext())) {

					// removeing trailing whitespaces for the php open
					String phpStart = yytext();
					int i = phpStart.length() - 1;
					while (i >= 0
							&& Character.isWhitespace(phpStart.charAt(i--))) {
						yypushback(1);
					}
					fStateStack.push(yystate());// YYINITIAL
					if (fStateStack.peek() == YYINITIAL) {
						// the simple case, just a regular scriptlet out in
						// content
						yybegin(ST_PHP_CONTENT);
						return PHP_OPEN;
					} else {
						if (yystate() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)
							fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
						else if (yystate() == ST_XML_ATTRIBUTE_VALUE_SQUOTED)
							fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
						else if (yystate() == ST_CDATA_TEXT) {
							fEmbeddedPostState = ST_CDATA_TEXT;
							fEmbeddedHint = XML_CDATA_TEXT;
						}
						yybegin(ST_PHP_CONTENT);
						assembleEmbeddedContainer(PHP_OPEN, PHP_CLOSE);
						if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
							yybegin(ST_BLOCK_TAG_SCAN);
							return BLOCK_TEXT;
						}
						// required help for successive embedded regions
						if (yystate() == ST_XML_TAG_NAME) {
							fEmbeddedHint = XML_TAG_NAME;
							fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
						} else if ((yystate() == ST_XML_ATTRIBUTE_NAME || yystate() == ST_XML_EQUALS)) {
							fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
							fEmbeddedPostState = ST_XML_EQUALS;
						} else if (yystate() == ST_XML_ATTRIBUTE_VALUE) {
							fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
							fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
						}
						return PROXY_CONTEXT;
					}
				}

			}
			case 350:
				break;
			case 132: {
				// end tag open
				fEmbeddedHint = XML_TAG_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_TAG_NAME);
				return XML_END_TAG_OPEN;
			}
			case 351:
				break;
			case 130: {
				return XML_TAG_ATTRIBUTE_VALUE_DQUOTE;
			}
			case 352:
				break;
			case 127: {
				return XML_TAG_ATTRIBUTE_VALUE_SQUOTE;
			}
			case 353:
				break;
			case 126: {
				// begin embedded region: " + fEmbeddedHint
				int incomingState = yystate();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				// tag inside of JSP attribute value start
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedContainer(XML_TAG_OPEN, new String[] {
						XML_TAG_CLOSE, XML_EMPTY_TAG_CLOSE });
				if (yystate() != ST_ABORT_EMBEDDED)
					yybegin(incomingState);
				return PROXY_CONTEXT;
			}
			case 354:
				break;
			case 125:
			case 129: {
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 355:
				break;
			case 122:
			case 123:
			case 124: {
				return doScanEndPhp(
						ProjectOptions.isSupportingAspTags(project),
						PHP_CONTENT, ST_PHP_CONTENT, ST_PHP_CONTENT);
			}
			case 356:
				break;
			case 60:
			case 62:
			case 151: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction attribute value");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_PI_ATTRIBUTE_NAME);
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 357:
				break;
			case 59: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction '='");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_PI_ATTRIBUTE_VALUE);
				return XML_TAG_ATTRIBUTE_EQUALS;
			}
			case 358:
				break;
			case 58: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction attribute name");//$NON-NLS-1$
				yybegin(ST_XML_PI_EQUALS);
				return XML_TAG_ATTRIBUTE_NAME;
			}
			case 359:
				break;
			case 54:
			case 55:
			case 56: {
				// block scan until close is found
				return doScan(
						"%>", false, false, XML_PI_CONTENT, ST_XML_PI_TAG_CLOSE, ST_XML_PI_TAG_CLOSE); //$NON-NLS-1$
			}
			case 360:
				break;
			case 53: {
				yybegin(ST_PI_CONTENT);
				return WHITE_SPACE;
			}
			case 361:
				break;
			case 49:
			case 50:
			case 51:
			case 52:
			case 144:
			case 145:
			case 146:
			case 239:
			case 264:
			case 265:
			case 280:
			case 281:
			case 293:
			case 305:
			case 312:
			case 316:
			case 319:
			case 320:
			case 321:
			case 322: {
				if (Debug.debugTokenizer)
					dump("processing instruction target");//$NON-NLS-1$
				fEmbeddedHint = XML_CONTENT;
				yybegin(ST_PI_WS);
				return XML_TAG_NAME;
			}
			case 362:
				break;
			case 44:
			case 45: {
				if (Debug.debugTokenizer)
					dump("comment content");//$NON-NLS-1$
				return scanXMLCommentText();
			}
			case 363:
				break;
			case 43: {
				if (Debug.debugTokenizer)
					dump("LINE FEED");//$NON-NLS-1$
				return WHITE_SPACE;
			}
			case 364:
				break;
			case 38:
			case 39: {
				if (Debug.debugTokenizer)
					dump("CDATA text");//$NON-NLS-1$
				fEmbeddedPostState = ST_CDATA_TEXT;
				fEmbeddedHint = XML_CDATA_TEXT;
				String blockContext = doBlockScan(
						"]]>", XML_CDATA_TEXT, ST_CDATA_END);//$NON-NLS-1$
				if (blockContext == XML_CDATA_TEXT)
					yybegin(ST_CDATA_END);
				return blockContext;
			}
			case 365:
				break;
			case 0:
			case 34:
			case 137:
			case 139:
			case 229:
			case 230:
			case 261: {
				if (Debug.debugTokenizer)
					dump("\nXML content");//$NON-NLS-1$
				return XML_CONTENT;
			}
			case 366:
				break;
			case 5:
			case 8:
			case 9:
			case 10:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 28:
			case 48: {
				if (Debug.debugTokenizer)
					dump("white space");//$NON-NLS-1$
				return WHITE_SPACE;
			}
			case 367:
				break;
			case 14:
			case 70:
			case 72:
			case 73:
			case 158: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction attribute value");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_DHTML_ATTRIBUTE_NAME);
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 368:
				break;
			case 16:
			case 74: {
				// inappropriate tag name
				if (!fStateStack.empty()
						&& (fStateStack.peek() == ST_XML_ATTRIBUTE_VALUE_SQUOTED || fStateStack
								.peek() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)) {
					yybegin(ST_ABORT_EMBEDDED);
					yypushback(yylength() - 1);
					return XML_TAG_ATTRIBUTE_VALUE;
				}
				yybegin(YYINITIAL);
				return XML_CONTENT;
			}
			case 369:
				break;
			case 27:
			case 110:
			case 111:
			case 208:
			case 251:
			case 252:
			case 273:
			case 274:
			case 287:
			case 288:
			case 301:
			case 309:
			case 313: {
				if (Debug.debugTokenizer)
					dump("elementdecl contentspec");//$NON-NLS-1$
				return XML_ELEMENT_DECL_CONTENT;
			}
			case 370:
				break;
			case 29:
			case 117:
			case 118:
			case 221:
			case 256:
			case 257:
			case 276:
			case 277:
			case 289:
			case 290:
			case 303:
			case 310:
			case 314: {
				if (Debug.debugTokenizer)
					dump("attlist contentspec");//$NON-NLS-1$
				return XML_ATTLIST_DECL_CONTENT;
			}
			case 371:
				break;
			case 35:
			case 79:
			case 83:
			case 87: {
				if (Debug.debugTokenizer)
					dump("\nstart tag open");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_TAG_NAME);
				return XML_TAG_OPEN;
			}
			case 372:
				break;
			case 36:
			case 37:
			case 40:
			case 41:
			case 42:
			case 46:
			case 47:
			case 57:
			case 61:
			case 63:
			case 64:
			case 65:
			case 67:
			case 71:
			case 76:
			case 84:
			case 89:
			case 90:
			case 91:
			case 92:
			case 94:
			case 95:
			case 97:
			case 102:
			case 107:
			case 114:
			case 128:
			case 131: {
				if (Debug.debugTokenizer)
					System.out
							.println("!!!unexpected!!!: \"" + yytext() + "\":" + //$NON-NLS-2$//$NON-NLS-1$
									yychar + "-" + (yychar + yylength()));//$NON-NLS-1$
				return UNDEFINED;
			}
			case 373:
				break;
			case 66: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 374:
				break;
			case 68: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction attribute name");//$NON-NLS-1$
				yybegin(ST_DHTML_EQUALS);
				return XML_TAG_ATTRIBUTE_NAME;
			}
			case 375:
				break;
			case 69: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction '='");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_DHTML_ATTRIBUTE_VALUE);
				return XML_TAG_ATTRIBUTE_EQUALS;
			}
			case 376:
				break;
			case 75: {
				// tag close
				fEmbeddedHint = UNDEFINED;
				if (isBlockMarker()) {
					fEmbeddedHint = getBlockMarkerContext();
					fEmbeddedPostState = ST_BLOCK_TAG_SCAN;
					yybegin(ST_BLOCK_TAG_SCAN);
				} else
					yybegin(YYINITIAL);
				return XML_TAG_CLOSE;
			}
			case 377:
				break;
			case 77:
			case 78: {
				if (Debug.debugTokenizer)
					dump("tag name");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 378:
				break;
			case 80: {
				// attr name
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_EQUALS);
				return XML_TAG_ATTRIBUTE_NAME;
			}
			case 379:
				break;
			case 81: {
				// equals
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_ATTRIBUTE_VALUE);
				return XML_TAG_ATTRIBUTE_EQUALS;
			}
			case 380:
				break;
			case 82:
			case 166: {
				// attr value
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 381:
				break;
			case 85: {
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
				yybegin(ST_XML_ATTRIBUTE_VALUE_DQUOTED);
				fStateStack.push(yystate());
				assembleEmbeddedContainer(XML_TAG_ATTRIBUTE_VALUE_DQUOTE,
						XML_TAG_ATTRIBUTE_VALUE_DQUOTE);
				fStateStack.pop();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return PROXY_CONTEXT;
			}
			case 382:
				break;
			case 86: {
				// begin embedded region: " + fEmbeddedHint
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
				yybegin(ST_XML_ATTRIBUTE_VALUE_SQUOTED);
				fStateStack.push(yystate());
				// JSP attribute value start - complex single quoted
				assembleEmbeddedContainer(XML_TAG_ATTRIBUTE_VALUE_SQUOTE,
						XML_TAG_ATTRIBUTE_VALUE_SQUOTE);
				fStateStack.pop();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return PROXY_CONTEXT;
			}
			case 383:
				break;
			case 88: {
				if (Debug.debugTokenizer)
					dump("declaration end");//$NON-NLS-1$
				if (Debug.debugTokenizer) {
					if (fStateStack.peek() != YYINITIAL)
						System.out.println("end embedded region");//$NON-NLS-1$
				}
				yybegin(fStateStack.pop());
				return XML_DECLARATION_CLOSE;
			}
			case 384:
				break;
			case 93: {
				if (Debug.debugTokenizer)
					dump("doctype type");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_EXTERNAL_ID);
				return XML_DOCTYPE_NAME;
			}
			case 385:
				break;
			case 96:
			case 98:
			case 99:
			case 100:
			case 179:
			case 180:
			case 183:
			case 184:
			case 246: {
				if (Debug.debugTokenizer)
					dump("doctype public reference");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_ID_SYSTEM);
				return XML_DOCTYPE_EXTERNAL_ID_PUBREF;
			}
			case 386:
				break;
			case 101:
			case 103:
			case 104:
			case 105:
			case 191: {
				if (Debug.debugTokenizer)
					dump("doctype system reference");//$NON-NLS-1$
				yybegin(ST_XML_DECLARATION_CLOSE);
				return XML_DOCTYPE_EXTERNAL_ID_SYSREF;
			}
			case 387:
				break;
			case 106:
			case 108:
			case 109:
			case 199:
			case 200:
			case 203:
			case 204:
			case 249: {
				if (Debug.debugTokenizer)
					dump("elementdecl name");//$NON-NLS-1$
				yybegin(ST_XML_ELEMENT_DECLARATION_CONTENT);
				return XML_ELEMENT_DECL_NAME;
			}
			case 388:
				break;
			case 112: {
				if (Debug.debugTokenizer)
					dump("elementdecl close");//$NON-NLS-1$
				if (Debug.debugTokenizer) {
					if (fStateStack.peek() != YYINITIAL)
						System.out.println("end embedded region");//$NON-NLS-1$
				}
				yybegin(fStateStack.pop());
				return XML_DECLARATION_CLOSE;
			}
			case 389:
				break;
			case 113:
			case 115:
			case 116:
			case 212:
			case 213:
			case 216:
			case 217:
			case 254: {
				if (Debug.debugTokenizer)
					dump("attlist name");//$NON-NLS-1$
				yybegin(ST_XML_ATTLIST_DECLARATION_CONTENT);
				return XML_ATTLIST_DECL_NAME;
			}
			case 390:
				break;
			case 119: {
				if (Debug.debugTokenizer)
					dump("attlist close");//$NON-NLS-1$
				if (Debug.debugTokenizer) {
					if (fStateStack.peek() != YYINITIAL)
						System.out.println("end embedded region");//$NON-NLS-1$
				}
				yybegin(fStateStack.pop());
				return XML_DECLARATION_CLOSE;
			}
			case 391:
				break;
			case 120:
			case 121: {
				return doBlockTagScan();
			}
			case 392:
				break;
			default:
				if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
					yy_atEOF = true;
					yy_do_eof();
					return null;
				} else {
					yy_ScanError(YY_NO_MATCH);
				}
			}
		}
	}

}
